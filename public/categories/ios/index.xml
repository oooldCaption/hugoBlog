<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>iOS on 煎人寿</title>
        <link>http://47.99.84.217/categories/ios/</link>
        <description>Recent content in iOS on 煎人寿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 03 May 2019 20:48:49 +0800</lastBuildDate><atom:link href="http://47.99.84.217/categories/ios/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>分身不乏术,Objective-C的多线程</title>
        <link>http://47.99.84.217/post/ios-gcd-nsoperation/</link>
        <pubDate>Fri, 03 May 2019 20:48:49 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios-gcd-nsoperation/</guid>
        <description>&lt;p&gt;我们在现实生活中,往往会在统一调时间线上同时做好几件事情, 比如刷牙的时候看手机,为了不浪费时间,我们总是同时进行两件三件甚至更多的事情;而在编程的世界中, 我们可以通过软件或者硬件上实现多个线程并发执行的技术来做到类似现实世界中的行为, 这就叫做多线程;能够大大提升整体处理性能;&lt;/p&gt;
&lt;p&gt;很多编程语言都实现了这种功能,java, .net,C++, php的pthreads和swoole,oc当然也不例外, 下面我们就来了解一下我们在oc中会经常用到的多线程技术GCD和NSOperation,NSOperationQueue;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;gcd&#34;&gt;GCD&lt;/h2&gt;
&lt;h3 id=&#34;gcd的好处&#34;&gt;GCD的好处&lt;/h3&gt;
&lt;p&gt;能够充分利用iOS或者macOS多核心的特性,大大提高整体的处理性能和计算能力;&lt;/p&gt;
&lt;h3 id=&#34;gcd的队列和任务&#34;&gt;GCD的队列和任务&lt;/h3&gt;
&lt;h4 id=&#34;任务&#34;&gt;任务&lt;/h4&gt;
&lt;p&gt;即一个操作行为,或者是要执行的代码块; 类似买票的行为,即一个任务;&lt;/p&gt;
&lt;h4 id=&#34;队列&#34;&gt;队列&lt;/h4&gt;
&lt;p&gt;执行任务的调度池, 用来存放任务,一个一个的任务被创建好之后放入队列中等待执行; 采用先进先出的原则,类似排队买票的行为;&lt;/p&gt;
&lt;h5 id=&#34;同步队列sync&#34;&gt;同步队列(sync)&lt;/h5&gt;
&lt;p&gt;添加任务同步队列,任务会一个接着一个去执行,后一个任务等待前一个任务的完毕状态; 同步队列不会开启新的线程; 类似一个窗口买票的而行为, 长长的队伍只能慢慢的等待;&lt;/p&gt;
&lt;h5 id=&#34;异步队列async&#34;&gt;异步队列(async)&lt;/h5&gt;
&lt;p&gt;任务被添加到异步队列后, 如果线程开启的足够多, 那么每一个任务不会做任何等待. 每个任务都可已开启一新的线程去执行; 类似多个窗口买票的行为, 10个窗口,10个人买票,一个人一个窗口, 不用等待; 当然啦, 理论上是可行的,但是实际开启线程过多会很影响CPU的效率, CPU会一直对调度池进行轮询; CPU就累死了;所以, 合理开启线程个数还是很有必要的;&lt;/p&gt;
&lt;h3 id=&#34;gcd的使用&#34;&gt;GCD的使用&lt;/h3&gt;
&lt;p&gt;GCD的使用非常简单, 我们创建一个队列,然后将想要执行的任务添加到队列中;&lt;/p&gt;
&lt;h4 id=&#34;创建队列&#34;&gt;创建队列&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_CONCURRENT);
//全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
//主队列
dispatch_queue_t queue = dispatch_get_main_queue();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;任务-1&#34;&gt;任务&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 同步执行任务创建方法
dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});
// 异步执行任务创建方法
dispatch_async(queue, ^{
    // 这里放异步执行任务代码
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际使用当中,使用的比较多的就是&lt;code&gt;异步任务+并行队列&lt;/code&gt; ,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-(void)asyncWithParallelQueue{
   NSLog(@&amp;#34;currentThread---%@&amp;#34;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&amp;#34;asyncConcurrent---begin&amp;#34;);
    dispatch_queue_t queue = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_CONCURRENT);
    dispatch_async(queue, ^{
        // 追加任务1
        for (int i = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&amp;#34;1---%@&amp;#34;,[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_async(queue, ^{
        // 追加任务2
        for (int i = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&amp;#34;2---%@&amp;#34;,[NSThread currentThread]);      // 打印当前线程
        }
    });
    dispatch_async(queue, ^{
        // 追加任务3
        for (int i = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&amp;#34;3---%@&amp;#34;,[NSThread currentThread]);      // 打印当前线程
        }
    });
    NSLog(@&amp;#34;asyncConcurrent---end&amp;#34;);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到除了主线程之外，系统开启了3个线程，并且任务可以看做是同时执行的。（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）。所有任务是在打印的syncConcurrent&amp;mdash;begin和syncConcurrent&amp;mdash;end之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，如果存在空闲的线程可以继续执行任务）。&lt;/p&gt;
&lt;h3 id=&#34;线程之间的通信&#34;&gt;线程之间的通信&lt;/h3&gt;
&lt;p&gt;如果我们在主线中使用了耗时任务例如下载,合成图片,I/O等操作时, 会对UI造成阻塞, 造成界面不能响应触摸,滚动,刷新等异常,所以我们一般会将这些耗时操作放到子线程中进行执行, 这样就会有一个不可避免的问题,就是我们在子线程中处理完操作后需要把处理结果放到主线程中进行更新数据或者UI,这就会有一个线程之间通信的问题, 万幸的是,GCD已经为我们提供了相应的方法;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/**
 * 线程间通信
 */
- (void)sendMSG{
    // 获取全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 获取主队列
    dispatch_queue_t mainQueue = dispatch_get_main_queue();
    dispatch_async(queue, ^{
        // 异步追加任务
        for (int i = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&amp;#34;1---%@&amp;#34;,[NSThread currentThread]);      // 打印当前线程
        }
        // 回到主线程
        dispatch_async(mainQueue, ^{
            // 追加在主线程中执行的任务
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&amp;#34;2---%@&amp;#34;,[NSThread currentThread]);      // 打印当前线程
        });
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;线程安全&#34;&gt;线程安全&lt;/h3&gt;
&lt;p&gt;假设我们有这样一个出售车票的场景: 余票500张,同时存在两个或者多个窗口进行售票,如果我们同时访问了这个余票并进行出售是不是会存在问题呢?&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (void)unSaveTicket{
    NSLog(@&amp;#34;currentThread---%@&amp;#34;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&amp;#34;semaphore---begin&amp;#34;);
    self.ticketCount = 500;
    // queue1 代表售卖窗口1
    dispatch_queue_t queue1 = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表售卖窗口2
    dispatch_queue_t queue2 = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_SERIAL);
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketunSafe];
    });
    dispatch_async(queue2, ^{
        [weakSelf saleTicketunSafe];
    });
}
/**
 * 售卖火车票(非线程安全)
 */
- (void)saleTicketunSafe {
    while (1) {
        if (self.ticketCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketCount--;
            NSLog(@&amp;#34;%@&amp;#34;, [NSString stringWithFormat:@&amp;#34;剩余票数：%d 窗口：%@&amp;#34;, self.ticketCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { //如果已卖完，关闭售票窗口
            NSLog(@&amp;#34;所有火车票均已售完&amp;#34;);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://52smile.vip/wp-content/uploads/2019/05/15568928052630.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;-w1086&#34;
	
	
&gt;￼ 可以看到,这里的票的个数是不安全的;造成这样的原因是因为多个线程访问同一个资源造成的,如果我们想要避免这种问题,我们需要对这个数据进行加锁;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/**
 * 线程安全：使用 synchronized 加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */
- (void)initTicketStatusSave {
    NSLog(@&amp;#34;currentThread---%@&amp;#34;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&amp;#34;semaphore---begin&amp;#34;);
    self.ticketCount = 50;
    // queue1 代表票售卖窗口1
    dispatch_queue_t queue1 = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表售卖窗口2
    dispatch_queue_t queue2 = dispatch_queue_create(&amp;#34;com.test.gcd&amp;#34;, DISPATCH_QUEUE_SERIAL);
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketSafe];
    });
    dispatch_async(queue2, ^{
        [weakSelf saleTicketSafe];
    });
}
/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {
    while (1) {
        @synchronized (self) {
            if (self.ticketCount &amp;gt; 0) {  //如果还有票，继续售卖
                self.ticketCount--;
                NSLog(@&amp;#34;%@&amp;#34;, [NSString stringWithFormat:@&amp;#34;剩余票数：%zd 窗口：%@&amp;#34;, self.ticketCount, [NSThread currentThread]]);
            } else { //如果已卖完，关闭售票窗口
                NSLog(@&amp;#34;所有火车票均已售完&amp;#34;);
                break;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;栅栏任务&#34;&gt;栅栏任务&lt;/h3&gt;
&lt;p&gt;有时候我们需要在某个函数后执行特定的任务. 这时候我们需要用到oc提供的栅栏函数&#39;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//栅格
-(void)barrier{
    /**
     不能使用quan&amp;#39;jue&amp;#39;de全局的并发队列. 会出现紊乱
     栅格函数使用后, 在栅格函数之前的, 先进行执行;
     在栅格函数之后, 等待栅格函数执行完成后在执行;
     */
    dispatch_queue_t queue = dispatch_queue_create(&amp;#34;dispatch_barrier&amp;#34;, DISPATCH_CURRENT_QUEUE_LABEL);
    dispatch_async(queue, ^{
        NSLog(@&amp;#34;---1----%@&amp;#34;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&amp;#34;---2----%@&amp;#34;,[NSThread currentThread]);
    });
    dispatch_barrier_async(queue, ^{
        NSLog(@&amp;#34;---barrier----%@&amp;#34;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&amp;#34;---3----%@&amp;#34;,[NSThread currentThread]);
    });
    dispatch_async(queue, ^{
        NSLog(@&amp;#34;---4----%@&amp;#34;,[NSThread currentThread]);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个执行是执行完1,2之后执行&lt;code&gt;barrier&lt;/code&gt;,然后等待&lt;code&gt;barrier&lt;/code&gt;执行完成后,执行3,4; 栅栏作为阻挡3,4的屏障,等待1,2 执行完成后才开始下一步的执行;&lt;/p&gt;
&lt;h3 id=&#34;延迟执行&#34;&gt;延迟执行&lt;/h3&gt;
&lt;p&gt;在指定某个时间间隔后执行某段任务.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//延时执行
-(void)disafter{
   //延时两秒钟执行 run
//    [self performSelector:@selector(run:) withObject:@&amp;#34;两好三坏&amp;#34; afterDelay:2];
    //可以传入其他队列
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)),
                   dispatch_get_main_queue(), ^{
                       [self run:@&amp;#34;两好三坏&amp;#34;];
    });
    // 使用NSTimer, 作为定时器进行操作
    [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(run:) userInfo:nil repeats:NO];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;一次性代码&#34;&gt;一次性代码&lt;/h3&gt;
&lt;p&gt;我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 函数。使用 dispatch_once 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//一次性函数, 类似单例,资源加载等;注意与懒加载的区别;
-(void)onceCode{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        NSLog(@&amp;#34;hhhh&amp;#34;);
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;eg: 单例:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static QKSingleton *_singleton;
/**
 返回一个单例对象
 @return 单例对象
 */
+(instancetype)shareSingleton{
        static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _singleton = [[self alloc] init];
    });
    return _singleton;
}
+(instancetype)allocWithZone:(struct _NSZone *)zone{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        _singleton = [super allocWithZone:zone];
    });
    return _singleton;
}
-(id)copyWithZone:(NSZone *)zone{
    return _singleton;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;快速迭代&#34;&gt;快速迭代&lt;/h3&gt;
&lt;p&gt;一般我们使用for循环进行数据遍历,然后再循环内对单个元素进行操作; 这样的问题在于如果我的数据量足够大或者单个元素操作耗时很高,那么在效率上会很低,因为这个实际上是在一个时间线的一个任务列中进行操作的,相当于在同步队列中执行一个串行队列; 而GCD为我们提供了一个快速迭代的方案: 场景如下: 我想把&lt;code&gt;From&lt;/code&gt;文件夹中的文件一个一个的移动或者复制到&lt;code&gt;TO&lt;/code&gt;文件夹中, 我们都知道I/O操作是很耗时间的. 下面有两个方法,一个是使用普通的for循环进行遍历, 一个是使用GCD提供的&lt;code&gt;dispatch_apply&lt;/code&gt;进行操作;大家可以看一下对比效果;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//快速遍历
-(void)quickBlock{
    /**
     可以i替代部分for循环的功能;
     eg: w想将一个文件夹中的文件剪切或者拷贝到另外一个文件夹中,如果我们通过for循环
     去做这件事情,当文件数量达到一定的数量的时候效率肯定降低; 但是如果我们使用GCD进行
     处理, 会好很多;
     */
    // 使用常规操作移动文件
    // [self  normalMoveFile];
    // 使用 GCD 移动文件
//    [self applayGCDMoveFile];
}
//使用 GCD 移动文件, 快速遍历
-(void)applayGCDMoveFile{
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 常规操作
    NSFileManager *mgr = [NSFileManager defaultManager];
    NSString *fromPath = @&amp;#34;/User/su/Desktop/Form&amp;#34;;
    NSString *toPath = @&amp;#34;/User/su/Desktop/To&amp;#34;;
    NSArray *subPaths = [mgr subpathsAtPath:fromPath];
    dispatch_apply(subPaths.count, queue, ^(size_t index) {
        NSString *subPath = subPaths[index];
        NSString *fromFullPath = [fromPath stringByAppendingPathComponent:subPath];
        NSString *toFullPath = [toPath stringByAppendingPathComponent:subPath];
        [mgr moveItemAtPath:fromFullPath toPath:toFullPath error:nil];
    });
}
//常规移动文件操作
-(void)normalMoveFile{
    // 常规操作
    NSFileManager *mgr = [NSFileManager defaultManager];
    NSString *fromPath = @&amp;#34;/User/su/Desktop/Form&amp;#34;;
    NSString *toPath = @&amp;#34;/User/su/Desktop/To&amp;#34;;
    NSArray *subPaths = [mgr subpathsAtPath:fromPath];
    for (NSString *subPath  in subPaths) {
        NSString *fromFullPath = [fromPath stringByAppendingPathComponent:subPath];
        NSString *toFullPath = [toPath stringByAppendingPathComponent:subPath];
        [mgr moveItemAtPath:fromFullPath toPath:toFullPath error:nil];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;gcd队列组&#34;&gt;GCD队列组&lt;/h3&gt;
&lt;p&gt;我们有的时候可能会遇到需要合并多个线程中的执行结果, 例如下载多个素材后进行合并; 或者是类似迅雷分块下载后的文件合并;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//GCD队列组
-(void)GCDWithGroup{
    /*
     合并两张图片或者多个任务处理完成后合并结果
     */
    //定义一个c并行队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    //创建一个队列组
    dispatch_group_t group = dispatch_group_create();
    //异步任务添加到队列组
    dispatch_group_async(group, queue, ^{
        //sub task
    });
    //异步任务添加到队列组
    dispatch_group_async(group, queue, ^{
        //sub task
    });
    //异步任务添加到队列组
    dispatch_group_async(group, queue, ^{
        //sub task ....
    });
    //监听队列组各个子任务完成后的合并
    dispatch_group_notify(group, queue, ^{
        // sub task finish
        //TODO
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;nsoperation-nsoperationqueue&#34;&gt;NSOPeration NSOperationQueue&lt;/h2&gt;
&lt;p&gt;与GCD的定义类似, 也存在任务和队列的概念,基本一致;在此就不在重复啦;&lt;/p&gt;
&lt;h3 id=&#34;nsoperationqueue&#34;&gt;NSOperationQueue&lt;/h3&gt;
&lt;p&gt;任务队列,可以开启串行&amp;amp;并行队列 我们可以通过 &lt;code&gt;maxConcurrentOperationCount&lt;/code&gt;进行设置,决定是以何种队列进行执行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。&lt;/li&gt;
&lt;li&gt;maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。&lt;/li&gt;
&lt;li&gt;maxConcurrentOperationCount 大于1时，队列为并发队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nsoperation&#34;&gt;NSOperation&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSOPeration&lt;/code&gt;是一个抽象类, 不作具体事务;具体事务由他的子类进行操作; 他有三个子类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用子类 NSInvocationOperation&lt;/li&gt;
&lt;li&gt;使用子类 NSBlockOperation&lt;/li&gt;
&lt;li&gt;自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nsinvocationoperation&#34;&gt;NSInvocationOperation&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    //通过suspened 可以执行挂起; 任务挂起后并咩有消失 , 通过设置suspended = NO. 继续任务
    //注意如果实在自定义的op对象时,是否需要考虑到界面优化
    //queue.suspended = YES;
    //定义操作任务
    NSInvocationOperation *opOne = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&amp;#34;xiaoxiaosu&amp;#34;];
    NSInvocationOperation *opTwo = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&amp;#34;xiaoxiaosu&amp;#34;];
    //添加任务
    [queue addOperation:opOne];
    [queue addOperation:opTwo];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;nsblockoperation&#34;&gt;NSBlockOperation&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//测试并行OperationQueue
-(void)operationQueue{
/*
    [NSOperationQueue mainQueue]; 如果使用mainqueueu, 那么获取到的是主队列
    如果使用的是alloc 方法获取,那么是 并行
 */
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    //设置最大并发数量, 值取1的时候可以看做是串行队列
    queue.maxConcurrentOperationCount = 3;
    //通过suspened 可以执行挂起; 任务挂起后并咩有消失 , 通过设置suspended = NO. 继续任务
    //注意如果实在自定义的op对象时,是否需要考虑到界面优化
    //queue.suspended = YES;
    //定义操作任务
    NSBlockOperation *opBlock = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;opBlock&amp;#34;);
    }];
    [opBlock addExecutionBlock:^{
        NSLog(@&amp;#34;opblock add block task&amp;#34;);
    }];
    //添加任务
    [queue addOperation:opBlock];
    //还可以通过block直接添加task
    [queue addOperationWithBlock:^{
    }];
    //取消所有队列, 注意与suspended的区别 ;
//    [queue cancelAllOperations];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;自定义nsoperation子类实现&#34;&gt;自定义NSOperation子类实现&lt;/h4&gt;
&lt;p&gt;这种子类一般可以做比较复杂的操作,我们可以省去在上面两种任务中大段又长又臭的代码,封装在子类实现;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// QKOperation.h 文件
#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface QKOperation.h : NSOperation
@end
// QKOperation.h.m 文件
#import &amp;#34;QKOperation.h&amp;#34;
@implementation QKOperation.h
- (void)main {
    if (!self.isCancelled) {
        for (int i = 0; i &amp;lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];
            NSLog(@&amp;#34;1---%@&amp;#34;, [NSThread currentThread]);
        }
    }
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;依赖操作&#34;&gt;依赖操作&lt;/h3&gt;
&lt;p&gt;我们有的时候可能会遇到这种情况: 任务1中的数据在任务2中是必须的,也就是说任务2是依赖于任务1的. 在GCD中我们可以使用栅栏进行操作, 在NSOperation中我们可以更方便的对任务进行设置依赖;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//NSOperation的依赖和监听
-(void)opRelyOnOp{
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;task1&amp;#34;);
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;task2&amp;#34;);
    }];
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;task3&amp;#34;);
    }];
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperation:op1];
    [queue addOperation:op2];
    [queue addOperation:op3];
    /*
     如果想要设置op3依赖op1,2执行完成后执行,可以使用如下的代码:
     也s可以op3 -&amp;gt; op2  -&amp;gt; op1
     但是要注意防止出现循环依赖: op3 -&amp;gt; op2  -&amp;gt; op1 -&amp;gt; op3
     # 也可以设置不同队列进行依赖
     queue queue1 两个不同队列之间的任务依赖
     */
    [op3 addDependency:op1];
    [op3 addDependency:op2];
    /*
     监听操作完成
     */
    op3.completionBlock = ^{
        NSLog(@&amp;#34;op3 task finish&amp;#34;);
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;nsoperation-线程通信&#34;&gt;NSOperation 线程通信&lt;/h3&gt;
&lt;p&gt;可以以很简明的代码实现GCD中的线程通信&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//NSOperation 的线程通信
-(void)opMsg{
    //eg:合成图片
    NSBlockOperation *down1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;img1 download&amp;#34;);
    }];
    NSBlockOperation *down2 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;img2 download&amp;#34;);
    }];
    NSBlockOperation *complate = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&amp;#34;合并 img1 &amp;amp; img2&amp;#34;);
    }];
    [complate addDependency:down1];
    [complate addDependency:down2];
    //线程间的基本通信;
    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    [queue addOperationWithBlock:^{
        NSURL *url = [NSURL URLWithString:@&amp;#34;remoteImgURL&amp;#34;];
        NSData *data = [NSData dataWithContentsOfURL:url];
        UIImage *image = [UIImage imageWithData:data];
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            UIImageView *imgview = [UIImageView new];
            imgview.image = image;
        }];
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;nsoperation-线程安全&#34;&gt;NSOperation 线程安全&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-(void)safeSallTicket{
    self.ticketCount = 50;
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = queue2.maxConcurrentOperationCount = 1;
    __weak typeof(self) weakSelf = self;
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [weakSelf sallTicketWithOp];
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [weakSelf sallTicketWithOp];
    }];
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}
-(void)sallTicketWithOp{
    while (1) {
        // 加锁
        [self.lock lock];
        if (self.ticketCount &amp;gt; 0) {
            //如果还有票，继续售卖
            self.ticketCount--;
            NSLog(@&amp;#34;%@&amp;#34;, [NSString stringWithFormat:@&amp;#34;剩余票数:%zd 窗口:%@&amp;#34;, self.ticketCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        }
        // 解锁
        [self.lock unlock];
        if (self.ticketCount &amp;lt;= 0) {
            NSLog(@&amp;#34;所有火车票均已售完&amp;#34;);
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;nsoperation-常用属性和方法&#34;&gt;NSOperation 常用属性和方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;取消操作方法
&lt;ul&gt;
&lt;li&gt;(void)cancel; 可取消操作，实质是标记 isCancelled 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;判断操作状态方法
&lt;ul&gt;
&lt;li&gt;(BOOL)isFinished; 判断操作是否已经结束。&lt;/li&gt;
&lt;li&gt;(BOOL)isCancelled; 判断操作是否已经标记为取消。&lt;/li&gt;
&lt;li&gt;(BOOL)isExecuting; 判断操作是否正在在运行。&lt;/li&gt;
&lt;li&gt;(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作同步
&lt;ul&gt;
&lt;li&gt;(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。&lt;/li&gt;
&lt;li&gt;(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。&lt;/li&gt;
&lt;li&gt;(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。&lt;/li&gt;
&lt;li&gt;(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>拥抱一下沉默的 NSString 吧~</title>
        <link>http://47.99.84.217/post/yong-bao-yi-xia-chen-mo-de-nsstring-ba/</link>
        <pubDate>Mon, 29 Apr 2019 09:36:24 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/yong-bao-yi-xia-chen-mo-de-nsstring-ba/</guid>
        <description>&lt;p&gt;NSString 作为作为OC的一种数据类型, 他帮我们做了很多事情, 而且也是我们在项目中运用频率很高的一个数据类型.我们经常会对它进行各式各样的操作,生成新的字符串,修改,查找,比较等等. 但是有人可能会问, 既然我已经有C的字符串了,为撒子还要在定义一个字符串对象呢? 嘿嘿,首先,我们使用NSString对象来处理字符串操作, 一方面是可以统一很多方面的东西,比如api, 例如NSArray,NSDictionary中都是存放的对象, 而且使用NSString还可以使用isKindofCLass的很多常用查询. 假如我们真的去使用了C的字符串去替代NSString的话, 那我们光是桥接代码就会让人写到吐,因为字符串在使用中的频率还是比较高的. 在和其他数据对象进行联合使用的时候,那种怪异的语法肯定也会让使用者大呼痛苦的. 向来注重用户体验的苹果肯定不会这样子干的,所以,定义一个NSString 对象还是很必要的. NSString 主要的方法都在 &lt;code&gt;Foundation/NSString.h&lt;/code&gt; 中定义, 提供了很多的方法接口&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;常量字符串&#34;&gt;常量字符串&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NSString *name = @&amp;#34;两好三坏&amp;#34;;
NSString *addName = [@&amp;#34;name:&amp;#34; stringByAppendingString:name];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;常量字符串不仅可以作为消息的参数, 还可以作为消息的接收者;&lt;/p&gt;
&lt;h3 id=&#34;nsstring-比较&#34;&gt;NSString 比较&lt;/h3&gt;
&lt;p&gt;字符串比较出结果后会返回一个 &lt;code&gt;NSComparisonResult&lt;/code&gt; 类型的枚举值. 分别是 * NSOrderedAscending 左侧小于右侧 * NSOrderedSame 两者相同 * NSOrderedDescending 右侧小于左侧&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//比较消息的接受者he参数字符串aString,参数不可以是nil,此方法区分大小写 如果相比较两个字符串是否相同的话还可以使用 isEqualToString:
-(NSComparisonResult)compare:(NSString *) aString;
// 不区分大小写比较, 上一个compare 的方法也可以通过添加参数进行选择大小写是否作为判断标准
-(NSComparisonResult) caseInsensitiveCompare:(NSString *)aString;
- (BOOL)isEqualToString:(NSString *)aString;
NSString *str0 = @&amp;#34;testString&amp;#34;;
NSString *str1 = @&amp;#34;testString&amp;#34;;
if([str0 isEqualToString:str1]){
   NSLog(@&amp;#34;字符串完全相等&amp;#34;);
}
//判断是否以 参数 开头的string
- (BOOL)hasPrefix:(NSString *)str;
//判断是够以 参数 结尾的string
- (BOOL)hasSuffix:(NSString *)str;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;截取字符串&#34;&gt;截取字符串&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 返回一个anIndex 开始到结尾的新字符串, 不包含form索引
- (NSString *)substringFromIndex:(NSUInteger)from;
//返回一个新字符串, 从to开始到结束,包含to的索引
- (NSString *)substringToIndex:(NSUInteger)to;
//通过一个range返回一个新的字符串对象
- (NSString *)substringWithRange:(NSRange)range;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;检索和置换&#34;&gt;检索和置换&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NSString *str0 = @“nice to meet you&amp;#34;;
NSString *temp = @&amp;#34;meet&amp;#34;;
NSRange rang = [str0 rangeOfString:temp];
NSLog(@&amp;#34;搜索的字符串在str0中起始点的index 为 %d&amp;#34;, rang.location);
NSLog(@&amp;#34;搜索的字符串在str0中结束点的index 为 %d&amp;#34;, rang.location + rang.length);
NSString *str = [str0 stringByReplacingCharactersInRange:rang withString:@&amp;#34;met&amp;#34;];
NSLog(@&amp;#34;替换后字符串为%@&amp;#34;, str);
//将字符串中&amp;#34; &amp;#34; 全部替换成 *
str = [str0 stringByReplacingOccurrencesOfString :@&amp;#34; &amp;#34; withString:@&amp;#34;@&amp;#34;];
NSLog(@&amp;#34;替换后字符串为%@&amp;#34;, str);
//还可以使用下面这个方法进行替换
//stringByReplacingOccurrencesOfString:(NSString *)withString:(NSString *) options:(NSStringCompareOptions) range:(NSRange)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;类型转换&#34;&gt;类型转换&lt;/h3&gt;
&lt;p&gt;可以使用一些方法将NSString 转成其它基础数据类型; NSString *temp = @&amp;ldquo;11.21&amp;rdquo;; * [str doubleValue]; * [str intValue] * [str integerValue] * [str boolValue] * &amp;hellip;&lt;/p&gt;
&lt;h3 id=&#34;路径处理&#34;&gt;路径处理&lt;/h3&gt;
&lt;p&gt;文件的路径可以使用 NSString 来表示,而且NSString提供了常用的处理文件路径的方法; eg:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// @&amp;#34;/tmp/image/cat.tiff&amp;#34;
//返回路径的最后一部分 -&amp;gt; cat.tiff
-(NSString *)lastPathComponent;
//将str 追加到现有字符串的末尾并返回.会根据需要自动追加分隔符
- (NSString *)stringByAppendingPathComponent:(NSString *)str;
//扩展名
-(NSString *)pathExtension;
//将 . 和指定的扩展名追加到到最后一个组成部分上
- (nullable NSString *)stringByAppendingPathExtension:(NSString *)str;
// 删除文件的扩展名.如果不存在,返回原来的字符串
-(NSString *)stringByDeletingPathExtension;
//判断是不是一个绝对路径
-(BOOL)isAbsolutePath;
...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;文件的输入和输出&#34;&gt;文件的输入和输出&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 通过一个 文件内容  初始化一个 nsstring;
[NSString stringWithContentsOfFile:@&amp;#34;&amp;#34; encoding:NSUTF8StringEncoding error:nil]
//将字符串内容写入到 path 的路径当中; 成功就返回YES/
[@&amp;#34;hduashfuiasifbsa&amp;#34; writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:nil];
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>iOS  block详解</title>
        <link>http://47.99.84.217/post/ios-block-xiang-jie/</link>
        <pubDate>Sun, 28 Apr 2019 11:35:44 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios-block-xiang-jie/</guid>
        <description>&lt;h3 id=&#34;什么是block&#34;&gt;什么是Block&lt;/h3&gt;
&lt;p&gt;block又叫块对象， 是MacOS X 10.6 以及 iOS4.0 平台下都可以使用的功能，&lt;code&gt;block&lt;/code&gt;不是oc的实现， 而是c语言的实现； 与其他编程语言中的&lt;code&gt;闭包&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;如何定义一个块对象&#34;&gt;如何定义一个块对象&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;^(返回值类型)(参数列) {表达式主体}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;无参数无返回值&#34;&gt;无参数无返回值&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void(^testBlock)(void) = ^(void){
    NSLog(@&amp;#34;无参数无返回值&amp;#34;);
}
testBlock();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;无参数有返回值&#34;&gt;无参数有返回值&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int(^testRetunValueBlock)(void) = ^(int){
    return  100;
}
int value = testRetunValueBlock();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;有参数无返回值&#34;&gt;有参数无返回值&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  void(^ testParamsBlcok) (NSString *) = ^(NSString *string){
            NSLog(@&amp;#34;%@&amp;#34;,string);
  };
  testParamsBlcok(@&amp;#34;hhh&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;有参数有返回值&#34;&gt;有参数有返回值&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NSString * (^tempBlock)(NSString *) = ^(NSString *string){
    return [NSString stringWithFormat:@&amp;#34;你最帅,%@&amp;#34;,string];
};
NSLog(@&amp;#34;%@&amp;#34;,tempBlock(@&amp;#34;两好三坏&amp;#34;));
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;使用typeof定义&#34;&gt;使用typeof定义&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef int (^MyBlock)(int , int);
@property (nonatomic,copy) MyBlock myBlockOne;
self.testBlock = ^int (int ,int){
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;block中变量行为&#34;&gt;Block中变量行为&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
void myFunc(int m, void (^b)(void) {
    printf(&amp;#34;%d: &amp;#34;,m);
    b();
}
int glob = 1000;
int main (void) {
    void (^block)(void);
    static int s = 20;
    int a = 20;
    block = ^{ print(&amp;#34;%d, %d, %d \n&amp;#34;,glob, s, a);};
    myFunc(1,block);
    s = 0;
    a = 0;
    glob = 5000;
    myFunc(2,block);
    testblock = ^{ print(&amp;#34;%d, %d, %d \n&amp;#34;,glob, s, a);};
    myFunc(3,testblock);
    return 0 ;
}
//输入结果:
1: 1000, 20,20
2: 5000, 0, 20
3: 5000, 0, 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个&lt;code&gt;block&lt;/code&gt;定义后, &lt;code&gt;block&lt;/code&gt;中包含外部变量 &lt;code&gt;glob&lt;/code&gt; 和 &lt;code&gt;main&lt;/code&gt;函数中局部变量,a,s;然后将&lt;code&gt;block&lt;/code&gt; 作为参数传递给&lt;code&gt;myFunc&lt;/code&gt;. 然后改变glob,a,s的值后再次调用&lt;code&gt;myFunc&lt;/code&gt;. 在&lt;code&gt;testBlock&lt;/code&gt;定以后, 调用&lt;code&gt;myFunc&lt;/code&gt;; 对比上面三个输出, block 只在代码块中保存自动变量的值,block 复制了block内部会使用到的变量;即使变量的值发生了变化, block在使用的时候也不会知道这个值变化; 那如果我们想知道这个值得变化或者想要修改这个变量该怎么办呢, 我们可以使用 &lt;code&gt;__block&lt;/code&gt;对想要使用的变量进行修饰, 如果我们使用了&lt;code&gt;__block&lt;/code&gt;修饰,name就是引用了这个变量的地址; 而且block只能访问,不能修改全局变量; [TOC] block使用变量相当于拷贝了一份变量在堆内存中，要注意对变量的影响&lt;/p&gt;
</description>
        </item>
        <item>
        <title>从 NSObject 占用的内存说起</title>
        <link>http://47.99.84.217/post/nsobject-size/</link>
        <pubDate>Sat, 30 Mar 2019 13:38:49 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/nsobject-size/</guid>
        <description>&lt;p&gt;之前iOS的一个 git 仓库看到一个面试问题, 一个 NSObject 对象占用多少内存, 看到这个面试题以后我想不是4个就是8个嘛, 因为之前我打印过 64位设备下 NSString 对象的内存大小就是8; 可是答案却有一点出乎意料, 是16, 于是我就找了些资料进行了一下深入的研究, 果然&amp;hellip;..&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们都知道, Objective-C 底层是使用 C和C++ , oc 的对象基本就是 C/C++的结构体;我们将 oc 的 m 文件使用 clang 编译后输出 cpp, 代码会告诉你对象的数据结构是类似如下所示的一个结构体:&lt;br&gt;
使用命令行将 &lt;code&gt;.m&lt;/code&gt; 转成 &lt;code&gt;cpp&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;命令行
xcrun  -sdk  iphoneos  clang  -arch  arm64  -rewrite-objc  OC源文件  -o  输出的CPP文件
eg:
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp
struct NSObject_IMPL {
    Class isa;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/2019-04-11-033022.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当然我们也可以跳转到 NSObject 的头文件看到类似的代码:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@interface NSObject &amp;lt;NSObject&amp;gt; {
#pragma clang diagnostic push
#pragma clang diagnostic ignored &amp;#34;-Wobjc-interface-ivars&amp;#34;
    Class isa  OBJC_ISA_AVAILABILITY;
#pragma clang diagnostic pop
}
...
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们可以点击跳转到 class 的定义去看一下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct objc_class *Class;
struct objc_object {
    Class _Nonnull isa __attribute__((deprecated));
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们发现, Class 其实是一个指针, 我们使用&lt;code&gt;NSObject *obj = [[NSObject alloc]init];&lt;/code&gt; 去初始化了一个 obj对象, 那么 obj 的指针就指向了刚刚分配给 class 指针的内存地址;&lt;/p&gt;
&lt;p&gt;我们可以使用一个方法来打印一下这个对象的大小:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; NSObject *obj = [[NSObject alloc]init];
//  获得NSObject类的实例对象的大小
NSLog(@&amp;#34;%zd&amp;#34;, class_getInstanceSize([NSObject class]));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打印结果就8, 但为什么会有人说对象的大小是16呢. 我们可以使用另外一个 api 来进行访问,再次打印一下这个对象的 size,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//获取obj指针指向内存的大小
 NSObject *obj = [[NSObject alloc]init];
 NSLog(@&amp;#34;%zd&amp;#34;, malloc_size((__bridge const void *)obj));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面方法返回的都是关于对象的大小, 为什么一个是 8 一个是 16 呢&amp;hellip;&lt;/p&gt;
&lt;p&gt;我们可以在 iOS 的 &lt;a class=&#34;link&#34; href=&#34;https://opensource.apple.com/tarballs/objc4/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;obj4源码&lt;/a&gt; 中找到答案&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;id
_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)
{
    id obj;
#if __OBJC2__
    // allocWithZone under __OBJC2__ ignores the zone parameter
    (void)zone;
    obj = class_createInstance(cls, 0);
#else
    if (!zone) {
    //不存在内存空间的话 去开辟一快新的内存
        obj = class_createInstance(cls, 0);
    }
    else {
        obj = class_createInstanceFromZone(cls, 0, zone);
    }
#endif
    if (slowpath(!obj)) obj = callBadAllocHandler(cls);
    return obj;
}
id
class_createInstance(Class cls, size_t extraBytes){
    return _class_createInstanceFromZone(cls, extraBytes, nil);
}
id
_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone,
                              bool cxxConstruct = true,
                              size_t *outAllocatedSize = nil){
    if (!cls) return nil;
    assert(cls-&amp;gt;isRealized());
    ...
    size_t size = cls-&amp;gt;instanceSize(extraBytes);
    if (outAllocatedSize) *outAllocatedSize = size;
    ...
    return obj;
}
size_t instanceSize(size_t extraBytes) {
    size_t size = alignedInstanceSize() + extraBytes;
    // CF requires all objects be at least 16 bytes.
    if (size &amp;lt; 16) size = 16;
    return size;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以通过 AllocWithZone 进行查找, 确定这个方法就是 alloc 时候调用的; 然后看到在这个方法中, 通过 &lt;code&gt;class_createInstance()&lt;/code&gt;进行创建; 我们可以用同样的方法进行查找关于&lt;code&gt;class_createInstance&lt;/code&gt;的信息, 可以看到在最后一个函数&lt;code&gt;size_t instanceSize&lt;/code&gt;中有一段关于限制 &lt;code&gt;size&lt;/code&gt;的代码, &lt;code&gt;if (size &amp;lt; 16) size = 16;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就解决了我们上面关于为什么 nsobject 对象是16 的的疑问;&lt;/p&gt;
&lt;p&gt;那么假如我们自定义一个继承自NSObject的 &lt;code&gt;TestTempClass&lt;/code&gt;，然后给这个类添加几个int类型的成员变量呢？&lt;/p&gt;
&lt;p&gt;这里就涉及到一个内存对齐的法则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据成员对齐规则：struct 或 union （以下统称结构体）的数据成员，第一个数据成员A放在偏移为 0 的地方，以后每个数据成员B的偏移为(#pragma pack(指定的数n) 与 该数据成员（也就是 B）的自身长度中较小那个数的整数倍，不够整数倍的补齐。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据成员为结构体：如果结构体的数据成员还为结构体，则该数据成员的“自身长度”为其内部最大元素的大小。(struct a 里存有 struct b，b 里有char,int,double等元素，那 b “自身长度”为 8)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构体的整体对齐规则：在数据成员按照上述第一步完成各自对齐之后，结构体本身也要进行对齐。对齐会将结构体的大小调整为(#pragma pack(指定的数n) 与 结构体中的最大长度的数据成员中较小那个的整数倍，不够的补齐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Xcode 中默认为#pragma pack(8）， 所以我们可以根据这个法则对对象占用的内存进行计算；&lt;/p&gt;
</description>
        </item>
        <item>
        <title>iOS中for 和 for-in 循环数组的小区别</title>
        <link>http://47.99.84.217/post/iosarrayforin/</link>
        <pubDate>Tue, 26 Mar 2019 17:06:28 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/iosarrayforin/</guid>
        <description>&lt;p&gt;在 OC 开发中, 数组是我们经常会用到的数据结构;而对数据进行遍历是很常见的操作, OC也为我们提供一下几种常用的操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for 循环,普通遍历&lt;/li&gt;
&lt;li&gt;for-in,快速 遍历&lt;/li&gt;
&lt;li&gt;Block&lt;/li&gt;
&lt;li&gt;枚举器NSEnumerator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前大部分情况下都是用for循环进行普通遍历, 但前几天我使用 for-in 去遍历一个数据的时候却报了异常;&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NSMutableArray *testArray = [NSMutableArray arrayWithObjects:@&amp;#34;耐克&amp;#34;,@&amp;#34;阿迪达斯&amp;#34;,@&amp;#34;李宁&amp;#34;,@&amp;#34;匡威&amp;#34;,nil];
for(NSString *temp in testArray)
{
if{[temp isEqualToString:@&amp;#34;阿迪达斯&amp;#34;])
{
NSLog(@&amp;#34;我不喜欢&amp;#34;);
[testArray removeObjective:temp];
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;报错信息如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Collection &amp;lt;__NSArrayM: 0x100601400&amp;gt; was mutated while being enumerated.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果我们去使用 for 进行普通遍历, 然后对数组进行修改或者删除就不会有这个错误;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;快速枚举的过程中不允许改变容器中的对象, 即: 不允许删除或者增加枚举容器中的对象, 因为对于一个既定的枚举器来说, 其内部的对象都已经对其进行了枚举排序, 如果你私自添加或者删除对象, 那么其既定的枚举序列就发生了改变, 而这种改变时系统不能识别的, 所以 OC中不允许这么做. 但有时候我们也必须在快速枚举的过程中删除一些枚举容器中的对象, 这时候, 我们就需要在删除完一个对象的时候, 对其进行break.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>iOS中KVO使用和底层原理</title>
        <link>http://47.99.84.217/post/kvo/</link>
        <pubDate>Mon, 17 Dec 2018 14:45:49 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/kvo/</guid>
        <description>&lt;p&gt;iOS 中 &lt;strong&gt;KVO&lt;/strong&gt;, 是&lt;code&gt;key-value-observing&lt;/code&gt; 的缩写, 是Objective-C 对&lt;strong&gt;观察者设计模式&lt;/strong&gt;的一种实现,类似观察者设计模式的还有&lt;code&gt;NSNotificationCenter&lt;/code&gt;,不过一个是一对一(&lt;code&gt;KVO&lt;/code&gt;),一个是一对多(&lt;code&gt;NSNotificationCenter&lt;/code&gt;) ; 一般继承自&lt;code&gt;NSObject&lt;/code&gt; 的对象都支持KVO. 日常开发中我们常常会监听数据模型的变化, 从而达到根据数据模型的修改对视图进行更新的要求;&lt;/p&gt;
&lt;h3 id=&#34;kvo-常用方法&#34;&gt;KVO 常用方法&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/*
注册监听器
监听器对象为observer，被监听对象为消息的发送者即方法的调用者在回调函数中会被回传
监听的属性路径为keyPath支持点语法的嵌套
监听类型为options支持按位或来监听多个事件类型
监听上下文context主要用于在多个监听器对象监听相同keyPath时进行区分
添加监听器只会保留监听器对象的地址，不会增加引用，也不会在对象释放后置空，因此需要自己持有监听对象的强引用，该参数也会在回调函数中回传
*/
- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;
eg:
[obj addObserver:observer forKeyPath:@&amp;#34;value&amp;#34; options:NSKeyValueObservingOptionNew context:NULL];
/*
删除监听器
监听器对象为observer，被监听对象为消息的发送者即方法的调用者，应与addObserver方法匹配
监听的属性路径为keyPath，应与addObserver方法的keyPath匹配
监听上下文context，应与addObserver方法的context匹配
*/
- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context;
/*
监听器对象的监听回调方法
keyPath即为监听的属性路径
object为被监听的对象
change保存被监听的值产生的变化
context为监听上下文，由add方法回传
*/
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change context:(void *)context;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;举个栗子-&#34;&gt;举个栗子 🌰&lt;/h3&gt;
&lt;p&gt;假如我的一个数据模型(student)的属性(age)发生了变化, 我需要在对应的视图进行修改这个属性的显示;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@property (nonatomic, strong) StudentModel  *student;
- (void)viewDidLoad {
  [super viewDidLoad];
  _student = [[Student alloc] init];
  _student.age = 10;
  [_student addObserver:self forKeyPath:@&amp;#34;age&amp;#34; options:NSKeyValueObservingOptionNew context:nil];
  [self requestData];
}
- (void)requestData{
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager POST:urlString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
       NSInteger age = [(NSDictionary *)responseObject[@&amp;#34;age&amp;#34;] integerValue];
       _student.age = age;
   } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
   }];
}
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary*)change context:(void *)context{
  if ([keyPath isEqualToString:@&amp;#34;age&amp;#34;] &amp;amp;&amp;amp; object == _student){
        NSLog(@&amp;#34;当前年龄是: %ld&amp;#34;,_student.age);
    }
}
- (void)dealloc{
  [_student removeObserver:self forKeyPath:@&amp;#34;age&amp;#34;];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;实现原理-&#34;&gt;实现原理 🚀&lt;/h3&gt;
&lt;p&gt;Apple 使用 isa 混写技术实现 KVO , 当观察对象 &lt;code&gt;testClass&lt;/code&gt;的时候, KVO 会动态创建一个继承自&lt;code&gt;testClass&lt;/code&gt;的类 &lt;code&gt;NSKVONotifying_testClass&lt;/code&gt; 并重写监听属性的 setter 方法,在调用 setter 的前后, 会观察对象属性的更改情况;子类拥有自己的 set 实现,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    [self willChangeValueForKey:@&amp;#34;value&amp;#34;];
    _value = value;
    [self didChangeValueForKey:@&amp;#34;value&amp;#34;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以, 通过 &lt;code&gt;set&lt;/code&gt;方法进行赋值, 通过 KVC &lt;code&gt;setValue:forKey:&lt;/code&gt;两种方式都可以对 KVO 生效; 但是如果想通过对成员变量直接赋值的话, 需要手动添加 KVO 才可以生效&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   QKTestObject *obj = [[QKTestObject alloc] init];
    QKTestObserver *observer = QKTestObserver.alloc.init;
//    通过 KVO 监听 obj 的变化
    [obj addObserver:observer forKeyPath:@&amp;#34;value&amp;#34; options:NSKeyValueObservingOptionNew context:NULL];
//    通过 setter 修改 value, 监听生效
//    obj.value = 2;
//    通过 kvo 修改 value , 监听生效
//    [obj setValue:@4 forKey:@&amp;#34;value&amp;#34;];
//    通过成员变量赋值. 未执行监听方法中的输出
    /*
        成员变量需要手动 添加 KVO , 监听才会生效
         [self willChangeValueForKey:@&amp;#34;value&amp;#34;];
         _value += 1;
         [self didChangeValueForKey:@&amp;#34;value&amp;#34;];
     */
    [obj changeValue];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://gitee.com/SuQiankun/iOSTestTool/blob/master/testTool/KVO/QKKVOTestCtrl.m&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;代码地址:&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>iOS 扩展&amp;代理&amp;通知</title>
        <link>http://47.99.84.217/post/ios-kuo-zhandai-litong-zhi/</link>
        <pubDate>Thu, 13 Dec 2018 17:39:05 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios-kuo-zhandai-litong-zhi/</guid>
        <description>&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;
&lt;h3 id=&#34;用途&#34;&gt;用途&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;声明私有属性&lt;/li&gt;
&lt;li&gt;声明私有成员变量&lt;/li&gt;
&lt;li&gt;声明私有方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;
&lt;p&gt;注意与 &lt;code&gt;category&lt;/code&gt; 的区别 * 编译时决议 * 只以声明的形式存在,多数情况下寄生在宿主类的&lt;code&gt;. m&lt;/code&gt;中 * 不能为系统类添加扩展&lt;/p&gt;
&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;准确的来说是一种软件设计模式, 代理模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iOS 中, 系统为我们提供了&lt;code&gt;@ protocol&lt;/code&gt; 形式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代理是一对一的 &lt;img src=&#34;https://img.52smile.vip/2018-12-13-094939.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协议有必须要实现的(@require), 不惜要实现的(option)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般用 weak 来规避循环引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;通知&#34;&gt;通知&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;观察者模式&lt;/strong&gt;来实现用于&lt;strong&gt;跨层传递消息&lt;/strong&gt;的机制&lt;/li&gt;
&lt;li&gt;传递方式 &lt;strong&gt;一对多&lt;/strong&gt; &lt;img src=&#34;https://img.52smile.vip/2018-12-13-095923.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;通知&#34;
	
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>iOS 分类源码解读</title>
        <link>http://47.99.84.217/post/ioscategory/</link>
        <pubDate>Thu, 13 Dec 2018 11:27:31 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ioscategory/</guid>
        <description>&lt;h3 id=&#34;分类的好处&#34;&gt;分类的好处&lt;/h3&gt;
&lt;p&gt;用分类声明一些私有方法;&lt;br&gt;
分类一些体积庞大的类文件,eg: AppDelegate, 组织代码更灵活&lt;br&gt;
把 framework 的私有方法公开&lt;/p&gt;
&lt;h3 id=&#34;分类的特点&#34;&gt;分类的特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运行时决议, 在 runtime 添加到类中, 在编辑的时候分类会将分类方法作为一个数组,动态的添加到宿主类中, 如果存在同名的扩展方法, 那么最后一个参与编译的方法生效并覆盖之前的同名方法(&lt;strong&gt;但是还是实际存在的,不过优先级没有分类中的高&lt;/strong&gt;), 但是可以通过一些代码决定调用最后一个参与编译的方法还是调用其他同名方法&lt;code&gt;memcopy(array-&amp;gt;lists, addedLists,addedCount *sizeof*array()-&amp;gt;lists[0])) 覆盖宿主 方法的原因,&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;为系统类添加分类&lt;/li&gt;
&lt;li&gt;名字相同的分类会引起编译报错&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分类中可以添加哪些内容&#34;&gt;分类中可以添加哪些内容&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可以添加实例方法&lt;/li&gt;
&lt;li&gt;类方法&lt;/li&gt;
&lt;li&gt;协议&lt;/li&gt;
&lt;li&gt;属性 只声明了 set get , 并没有在分类中添加实例变量&lt;/li&gt;
&lt;li&gt;添加分类的实例变量, 需要通过关联对象进行设置&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分类的结构体构成&#34;&gt;分类的结构体构成&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;//分类文件
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;struct category_t{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    //分类名称
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    const char *name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    //分类所属的数组类
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    classref_t cls;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    //实例方法列表
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    struct method_list_t *instanceMethods;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    //类方法列表
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    struct method_list_t *classMethods;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    //所有协议的方法列表
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    struct protocol_list_t *protocols;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    //添加的所有属性
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    struct protocol_list_t *instanceProperties;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    method_list_t *methodsForMeta(bool isMeta) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        if(isMeta) return classMethods;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        else return instanceMethods;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    protocol_list_t *propertiesForMeta(bool isMeta) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        if(isMeta) return nil;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        else return instanceProperties;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;分类的加载调用栈&#34;&gt;分类的加载调用栈&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;_objec_init&lt;br&gt;
入口调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map_2_images&lt;br&gt;
数据镜像映射之类的吧, 我也不怎么懂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map_images_nolock&lt;br&gt;
数据镜像映射之类的吧, 我也不怎么懂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read_images&lt;br&gt;
objec 源代码中, map_images_noloc会调用此方法, 将读取到的数据镜像,将解析到的信息(方法和协议)传递给&lt;code&gt;remethodizeClass&lt;/code&gt;(猜的), 添加到类和类的元类上&lt;br&gt;
&lt;img src=&#34;https://img.52smile.vip/2018-12-13-070041.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remethodizeClass&lt;br&gt;
整合class 中的所有分类, 进行操作;&lt;br&gt;
此过程会将分类的属性,协议,方法都添加到类中;&lt;br&gt;
下面会有详细的说明关于&lt;strong&gt;分类是如何加载的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;static void remethodizeClass(Class cls)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    category_list *cats;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    bool isMeta;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    runtimeLock.assertWriting();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    isMeta = cls-&amp;gt;isMetaClass();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[       // Re-methodizing: check for more categories]
if ((cats = unattachedCategoriesForClass(cls, false/&lt;em&gt;not realizing&lt;/em&gt;/))) {
if (PrintConnecting) {
[               _objc_inform(&amp;ldquo;CLASS: attaching categories to class &amp;lsquo;%s&amp;rsquo; %s&amp;rdquo;, ]
cls-&amp;gt;nameForLogging(), isMeta ? &amp;ldquo;(meta)&amp;rdquo; : &amp;ldquo;&amp;rdquo;);
}
attachCategories(cls, cats, true /&lt;em&gt;flush caches&lt;/em&gt;/);     &lt;br&gt;
free(cats);
}
}
```&lt;/p&gt;
&lt;h3 id=&#34;分类是如何加载的&#34;&gt;分类是如何加载的&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/2018-12-13-072228.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;remethodizeClass&#34;
	
	
&gt; &lt;img src=&#34;https://img.52smile.vip/2018-12-13-073451.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;方法覆盖&#34;&gt;方法覆盖&lt;/h3&gt;
&lt;p&gt;我们上面说了一些&lt;code&gt;category&lt;/code&gt;原理, 如果存在同名方法的话, 宿主类中的方法会被覆盖掉, 那么我们如何调用宿主类中被覆盖的方法呢?&lt;br&gt;
刚才说了, 并不是被覆盖掉了, 而是优先级的问题, 我们只要顺着方法列表找到最后一个对应名字的方法就可以啦~&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Class currentClass = [MyClass class];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;MyClass *my = [[MyClass alloc] init];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;if (currentClass) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    unsigned int methodCount;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Method *methodList = class_copyMethodList(currentClass, &amp;amp;methodCount);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IMP lastImp = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SEL lastSel = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    for (NSInteger i = 0; i &amp;lt; methodCount; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Method method = methodList[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                        encoding:NSUTF8StringEncoding];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        if ([@&amp;#34;printName&amp;#34; isEqualToString:methodName]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lastImp = method_getImplementation(method);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lastSel = method_getName(method);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    typedef void (*fn)(id,SEL);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    if (lastImp != NULL) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        fn f = (fn)lastImp;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        f(my,lastSel);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    free(methodList);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;通过关联对象给分类添加成员变量&#34;&gt;通过关联对象给分类添加成员变量&lt;/h3&gt;
&lt;p&gt;关联对象由&lt;code&gt;AssociationsManager&lt;/code&gt;管理并在 &lt;code&gt;AssociationsHashMap&lt;/code&gt;中存储;&lt;br&gt;
&lt;code&gt;AssociationsHashMap&lt;/code&gt; 是一个全局容器, 通过一个映射表来操作到具体不同的类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#import &amp;#34;MyClass.h&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@interface MyClass (Category1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@property(nonatomic,copy) NSString *name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#import &amp;#34;MyClass+Category1.h&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;#import &amp;lt;objc/runtime.h&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@implementation MyClass (Category1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;+ (void)load
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NSLog(@&amp;#34;%@&amp;#34;,@&amp;#34;load in Category1&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- (void)setName:(NSString *)name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    objc_setAssociatedObject(self,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             &amp;#34;name&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             name,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                             OBJC_ASSOCIATION_COPY);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- (NSString*)name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    NSString *nameObject = objc_getAssociatedObject(self, &amp;#34;name&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    return nameObject;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联对象实现原理&lt;br&gt;
&lt;img src=&#34;https://img.52smile.vip/2018-12-13-083719.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;关联对象实现原理&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>UI事件传递以及事件响应原理</title>
        <link>http://47.99.84.217/post/iostouchevent/</link>
        <pubDate>Tue, 11 Dec 2018 20:47:22 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/iostouchevent/</guid>
        <description>&lt;p&gt;CALayer -&amp;gt; content显示内容, 实际是合成了一个个位图; 用来展示 我们平常所说的掉帧也是因为位图合成后未来得及显示绘制造成的 view 提供内容, 负责处理触摸事件,参与视图响应链 layer, 负责内容上的显示, contents; 之所以这样设计是因为单一元件负责单元任务, 即单一原则;&lt;/p&gt;
&lt;h3 id=&#34;事件传递&#34;&gt;事件传递:&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//返回响应事件的视图
-(UIView *)hitTest:(CGPoint)point WithEvent:(UIEvent *)event;
//判断是否在响应区域内
-(BOOL)pointInside(CGPoint)point WithEvent:(UIEvent *)event;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;事件传递流程&#34;&gt;事件传递流程:&lt;/h4&gt;
&lt;p&gt;如何寻找合适的响应者来处理事件: 1. 判断主窗口是否可以接受触摸事件 2. 判断触摸点是否在自己的区域内( pointInside: withEvent:) 3. 子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） 事件传递给一个控件就会调用&lt;code&gt;hitTest: withEvent:&lt;/code&gt;, 通过这个特性, 可以重写&lt;code&gt;hitTest: withEvent&lt;/code&gt;方法返回指定的 view 用来接收事件的处理; &lt;img src=&#34;https://img.52smile.vip/2018-12-12-070429.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; eg: &lt;img src=&#34;https://img.52smile.vip/2018-12-12-082050.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; 在实际中响应事件是的&lt;code&gt;viewB1&lt;/code&gt;,虽然点击的位置在 &lt;code&gt;viewA2&lt;/code&gt; 和 &lt;code&gt;ViewB1&lt;/code&gt;的重复处, 但是由于 &lt;code&gt;view B1&lt;/code&gt; 的视图索引在 &lt;code&gt;viewA2&lt;/code&gt; 之上, 所以响应事件的是 ``viewB1`;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;hittestwithevent-系统实现&#34;&gt;hitTest:withEvent: 系统实现&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/2018-12-12-083719.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;hitTest:withEvent: 系统实现&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled  self.isHidden  self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    if ([self pointInside:point withEvent:event]) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;hitTest:withEvent:&lt;/code&gt; 首先检测是否允许视图接受触摸事件, 如果出现下面的情况, 不允许被触摸:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;视图被隐藏 &lt;code&gt;self.hidden == no&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;未启用用户交互 &lt;code&gt;self.userInteractionEnabled == NO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;视图的透明度小于0.001 &lt;code&gt;self.alpha &amp;lt; 0.01&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;视图的 pointInside:withEvent 返回 NO &lt;code&gt;pointInside:withEvent: == NO&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过重写&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法, 我们可以给某些控件增大可点击范围, 或者让某个控件的指定区域响应点击事件;&lt;/p&gt;
&lt;h4 id=&#34;eg--修改触摸范围-向上偏移10个点&#34;&gt;eg : 修改触摸范围, 向上偏移10个点&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled  self.isHidden  self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    CGRect touchRect = CGRectInset(self.bounds, -10, -10);
    if (CGRectContainsPoint(touchRect, point)) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;eg--定义一个方形的-button-只允许圆形区域内才可以接受响应&#34;&gt;eg : 定义一个方形的 button, 只允许圆形区域内才可以接受响应&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/2018-12-12-090217.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    if (!self.userInteractionEnabled 
        [self isHidden] 
        self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    if ([self pointInside:point withEvent:event]) {
        //遍历当前对象的子视图
        __block UIView *hit = nil;
        [self.subviews enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            // 坐标转换
            CGPoint vonvertPoint = [self convertPoint:point toView:obj];
            //调用子视图的hittest方法
            hit = [obj hitTest:vonvertPoint withEvent:event];
            // 如果找到了接受事件的对象，则停止遍历
            if (hit) {
                *stop = YES;
            }
        }];
        if (hit) {
            return hit;
        }
        else{
            return self;
        }
    }
    else{
        return nil;
    }
}
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
{
    CGFloat x1 = point.x;
    CGFloat y1 = point.y;
    CGFloat x2 = self.frame.size.width / 2;
    CGFloat y2 = self.frame.size.height / 2;
    double dis = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    // 67.923
    if (dis &amp;lt;= self.frame.size.width / 2) {
        return YES;
    }
    else{
        return NO;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;eg--将触摸事件传递给下一层的视图&#34;&gt;eg : 将触摸事件传递给下一层的视图&lt;/h4&gt;
&lt;p&gt;有时候我们需要忽略当前视图的触摸事件, 让他下一级的视图去响应触摸; 我们可以覆盖此方法, 返回其中一个包含触摸点的子视图;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView == self) {
        hitTestView = nil;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;eg--将触摸事件传递给子视图&#34;&gt;eg : 将触摸事件传递给子视图&lt;/h4&gt;
&lt;p&gt;假设一个scrollview 构成的图像轮播, pagungEnable=YES, clipsToBounds 设置为 NO , scrollveiw 的响应不仅在自己的边界内, 而且在父视图的边界也要可以响应&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView) {
        hitTestView = self.scrollView;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>模仿 tableViewCell 实现一个简易的重用视图</title>
        <link>http://47.99.84.217/post/reusecell/</link>
        <pubDate>Mon, 10 Dec 2018 15:29:15 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/reusecell/</guid>
        <description>&lt;p&gt;之前面试的时候会有很多人问道 UITableviewCellde 重用机制, 大部分回答都是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在缓存池初中通过 dequeueReusableCellWithIdentifier:CellIdentifier 方法取出可重用的 cell, 在一个 cell 离开屏幕显示的范围内, 会自动被加入到缓存池中,然后在缓存池中取出一个 cell, 放到当前屏幕上;用重用机制会节省性能，避免出现一些因为网络因素而造成的卡顿现象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;复用机制避免了大量的初始化过程, 我们可以节约很大一部分资源; 下面我们来试着模仿 tableview 创建一个复用视图吧~&lt;/p&gt;
&lt;h3 id=&#34;实例化一个重用池&#34;&gt;实例化一个重用池;&lt;/h3&gt;
&lt;p&gt;新建一个继承自&lt;code&gt;NSObject&lt;/code&gt; 的类, reusePool; 在reusePool 中定义三个方法,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获取重用 view &lt;code&gt;-(UIView *)getReuseTableView;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 view 到重用池中 &lt;code&gt;-(void)addViewForReusePool:(UIView *)view;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重置重用池 &lt;code&gt;-(void)reset;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在类的&lt;code&gt;.m&lt;/code&gt;文件中, 实现刚才定义的几个方法, 并定义两个属性, &lt;code&gt;wattingQueue&lt;/code&gt; 和 &lt;code&gt;usingQueue&lt;/code&gt;, 作为存放视图的容器; 实现刚才定义的几个方法&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (instancetype)init
{
    self = [super init];
    if (self) {
        _waitingQueue  = [NSMutableSet set];
        _useingQueue   = [NSMutableSet set];
    }
    return self;
}
// 如果存在, 从等待队列中移除一个, 在使用中的队列增加一个
-(UIView *)getReuseTableView{
    UIView *view = [_waitingQueue anyObject];
    if (view == nil) {
        return nil;
    }else{
        [_waitingQueue removeObject:view];
        [_useingQueue addObject:view];
        return view;
    }
}
//添加可重用视图到重用池
-(void)addViewForReusePool:(UIView *)view{
    if (view == nil) {
        return;
    }
    [_useingQueue addObject:view];
}
//重置重用池
-(void)reset{
    UIView *view = nil;
    while ((view = [_useingQueue anyObject]) ) {
        [_useingQueue removeObject:view];
        [_waitingQueue addObject:view];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;实现视图&#34;&gt;实现视图&lt;/h3&gt;
&lt;p&gt;定义一个继承自&lt;code&gt;UITableView&lt;/code&gt; 的视图类, &lt;code&gt;reuseTableView&lt;/code&gt;; 给 &lt;code&gt;reuseTableView&lt;/code&gt; 设置一个代理方法, 来获取需要用到的数据;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;
@protocol QKReuseTableViewDataSource &amp;lt;NSObject&amp;gt;
/**
 获取字母索引条
 @param tableview tableview
 @return 结果数组
 */
-(NSArray &amp;lt;NSString*&amp;gt; *)indexTitleFromReuseTable:(UITableView *)tableview;
@end
@interface QKReuseTableView : UITableView
@property (nonatomic,weak) id   &amp;lt;QKReuseTableViewDataSource&amp;gt; indexDataSource;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;. m&lt;/code&gt; 文件中定义两个属性&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@interface QKReuseTableView ()
{
    UIView *containerView;
    QKReusePool *reusePool;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重写 &lt;code&gt;tableview&lt;/code&gt; 的&lt;code&gt;reloadData&lt;/code&gt; 方法&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-(void)reloadData{
    [super reloadData];
    if (containerView == nil) {
        containerView = [[UIView alloc] init];
        containerView.backgroundColor = UIColor.whiteColor;
        [self.superview insertSubview:containerView aboveSubview:self];
    }
    if (reusePool == nil) {
        reusePool = [[QKReusePool alloc] init];
    }
    //初始化的时候重置重用池
    [reusePool reset];
//    reload 索引条
    [self reloadIndexTitle];
}
-(void)reloadIndexTitle{
//    设置一个title数组
    NSArray &amp;lt;NSString *&amp;gt; * titleArray  = nil;
    if ([self.indexDataSource respondsToSelector:@selector(indexTitleFromReuseTable:)]) {
        titleArray = [self.indexDataSource indexTitleFromReuseTable:self];
    }
    if (!titleArray  titleArray.count&amp;lt;=0) {
        [containerView setHidden:YES];
        return;
    }
    NSUInteger count = titleArray.count;
    CGFloat btnWidth = 60;
    CGFloat btnHeight = self.frame.size.height/count;
    for (int i = 0; i&amp;lt; count; i++) {
        NSString *title = [titleArray objectAtIndex:i];
        UIButton *btn = (UIButton *)[reusePool getReuseTableView];
        if (btn == nil) {
            btn = [[UIButton alloc] initWithFrame:CGRectZero];
            btn.backgroundColor = UIColor.whiteColor;
            [reusePool addViewForReusePool:btn];
            NSLog(@&amp;#34;creat  a  btn&amp;#34;);
        }else{
            NSLog(@&amp;#34;reuse button&amp;#34;);
        }
        [containerView addSubview:btn];
        [btn setTitle:title forState:UIControlStateNormal];
        [btn  setTitleColor:UIColor.blackColor forState:UIControlStateNormal];
        [btn setFrame:CGRectMake(0, i*btnHeight, btnWidth, btnHeight)];
    }
    [containerView setHidden:NO];
    containerView.frame = CGRectMake(self.frame.origin.x + self.frame.size.width - btnWidth, self.frame.origin.y, btnWidth, self.frame.size.height);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码在reuseCell 文件夹 &lt;a class=&#34;link&#34; href=&#34;https://gitee.com/SuQiankun/iOSTestTool.git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;git仓库链接地址&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>对 tableView 数据源中的时间进行分组排序</title>
        <link>http://47.99.84.217/post/groupwithtime/</link>
        <pubDate>Mon, 10 Dec 2018 15:15:33 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/groupwithtime/</guid>
        <description>&lt;p&gt;遇到一个需求, 需要从后台返回的消息或者交易列表中根据日期进行分组排序, 界面类似 &lt;img src=&#34;https://img.52smile.vip/2018-12-10-071940.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt; 根据日期或者消息类型,等等进行排序; 数据格式类似下面这种:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
    {
    &amp;#34;date&amp;#34;:&amp;#34;2018-12-12&amp;#34;,
    &amp;#34;titleInfo&amp;#34;:&amp;#34;xxxxx&amp;#34;,
    },
    {
    &amp;#34;date&amp;#34;:&amp;#34;2018-12-12&amp;#34;,
    &amp;#34;titleInfo&amp;#34;:&amp;#34;xxxxx&amp;#34;,
    },
    {
    &amp;#34;date&amp;#34;:&amp;#34;2018-12-12&amp;#34;,
    &amp;#34;titleInfo&amp;#34;:&amp;#34;xxxxx&amp;#34;,
    },
    {
    &amp;#34;date&amp;#34;:&amp;#34;2018-12-12&amp;#34;,
    &amp;#34;titleInfo&amp;#34;:&amp;#34;xxxxx&amp;#34;,
    },
]
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;可以再获取到数据后对数据先分好组 然后在每一个创建空数组 在遍历数据源中的数据 如果时间和组头一样就加入对应空数组中; 代码如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (void)handleArraysAction {
    NSMutableArray *timeArr = [NSMutableArray array];
    __weak typeof(self) weakSelf = self;
    [self.requestDataArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        QKTimeGroupModel* headModel = obj;
        [timeArr addObject:headModel.date_str];
    }];
    NSSet *set = [NSSet setWithArray:timeArr];//使用asset把timeArr的日期去重
    NSArray *userArray = [set allObjects];//去重后的时间数组
    //遍历userArray   按照userArray里的时间分成几个组每个组都是空的数组
    //    self.dataSource = [NSMutableArray array];
    [userArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        NSMutableArray *arr = [NSMutableArray array];
        [weakSelf.dataSource addObject:arr];
    }];
    //遍历self.requestDataArray取其中每个数据的日期看看与userArray里的那个日期匹配就把这个数据装到sectionArray对应的组中
    [self.requestDataArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        QKTimeGroupModel* headModel = obj;
        for (NSString *timeStr in userArray) {
            if ([timeStr isEqualToString:headModel.date_str]) {
                NSMutableArray *emptyArr = [weakSelf.dataSource objectAtIndex:[userArray indexOfObject:timeStr]];//取到对应的空数组
                [emptyArr addObject:headModel];
            }
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以额外定义一个时间变量和一个 section 的变量, 循环对比每个 date 的值, 然后根据对比结果决定加入到数组不同的 section 中; 代码如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-(void)testDict{
    NSMutableArray *modelArray = [QKTimeGroupModel getData];
    NSString *pervDate = @&amp;#34;temp&amp;#34;;
    NSUInteger sectionNumber = 0;
    for (int i = 0; i &amp;lt; modelArray.count; i++) {
        QKTimeGroupModel *model = modelArray[i];
        if ([model.date_str isEqualToString:pervDate]) {
            NSMutableArray *arr = (NSMutableArray *)modelArray[sectionNumber];
            [arr addObject:model];
            [modelArray replaceObjectAtIndex:sectionNumber withObject:arr];
        }else{
            pervDate = model.date_str;
            NSMutableArray *arr = [NSMutableArray array];
            [arr addObject:model];
            [modelArray addObject:arr];
            sectionNumber = modelArray.count - 1;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>UITableView性能优化</title>
        <link>http://47.99.84.217/post/uitableview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <pubDate>Tue, 18 Sep 2018 18:03:26 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/uitableview%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;p&gt;UItableview 是 iOS 开发中最常用的 ui 控件之一,也是最常出现的控件之一; 常常负责一些列表数据的渲染,因此对 UITablevie 进行性能优化是很有必要的;&lt;/p&gt;
&lt;h3 id=&#34;1-cell-重用&#34;&gt;1 cell 重用&lt;/h3&gt;
&lt;h4 id=&#34;11-数据源方法优化&#34;&gt;1.1 数据源方法优化&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次刷新都去创建新的 cell, 性能; 我们会传建一个静态的变量来作为标识符去创建 cell, 每个 cell 都会注册一个标识符,放入缓存中,如果需要调用,就从缓存池中找到对应的 id, 只有一处屏幕的 cell 才会被放入缓存中&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-objectice-c&#34; data-lang=&#34;objectice-c&#34;&gt;static NSString *resuseID = @&amp;#34;CellID&amp;#34;;
UITableviewCell *cell= [tableview dequeueReusableCellWithIdentifier:resuseID];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;12-缓存池的实现&#34;&gt;1.2 缓存池的实现&lt;/h4&gt;
&lt;p&gt;当 cell 要初始化的时候, tableview 会在堆中开辟内存为 cell 缓存使用. cell 的重用通过 identifier 标识不同类型的 cell,&lt;/p&gt;
&lt;h4 id=&#34;13-缓存池取出可重用-cell-两种方法的区别&#34;&gt;1.3 缓存池取出可重用 cell 两种方法的区别&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; //  这个方法会查询可重用Cell，如果注册了原型Cell，能够查询到，否则，返回nil；而且需要判断if（cell == nil），才会创建Cell，不推荐
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-(nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;//   使用这个方法之前，必须通过xib（storyboard）或是Class（纯代码）注册可重用Cell，而且这个方法一定会返回一个Cell
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-(__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;//注册 cell
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(5_0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier NS_AVAILABLE_IOS(6_0);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-定义尽量少类型的-cell-以及善用-hidden-隐藏或者显示-subviews&#34;&gt;2 定义尽量少类型的 cell 以及善用 hidden 隐藏或者显示 subviews&lt;/h3&gt;
&lt;h4 id=&#34;21定义一种类型的-cell&#34;&gt;2.1定义一种类型的 cell&lt;/h4&gt;
&lt;p&gt;​ 分析 cell 的结构,尽量将相同内容抽取到一种样式 cell 中,前面已经说到了 cell 的重用机制,同种类型保证重用&lt;/p&gt;
&lt;h4 id=&#34;22-善用-hidden-去显示或者隐藏-subviews&#34;&gt;2.2 善用 hidden 去显示或者隐藏 subviews&lt;/h4&gt;
&lt;p&gt;​ 与2.1对应&lt;/p&gt;
&lt;h3 id=&#34;3-提前计算并缓存-cell-的高度&#34;&gt;3 提前计算并缓存 cell 的高度&lt;/h3&gt;
&lt;p&gt;在iOS中，不设UITableViewCell的预估行高的情况下，会优先调用”tableView:heightForRowAtIndexPath:”方法，获取每个Cell的即将显示的高度，从而确定UITableView的布局，实际就是要获取contentSize（UITableView继承自UIScrollView,只有获取滚动区域，才能实现滚动）,然后才调用”tableView:cellForRowAtIndexPath”,获取每个Cell，进行赋值. 如果项目中 cell 比较多,是非常影响性能的; 可以使用&lt;strong&gt;UITableView-FDTemplateLayoutCell&lt;/strong&gt; 去计算 cell 的高度,以及缓存&lt;/p&gt;
&lt;h3 id=&#34;4-异步绘制&#34;&gt;4 异步绘制&lt;/h3&gt;
&lt;p&gt;减少cell 在主线程的时间消耗,异步渲染视图, 如果图片较多,可以使用预渲染技术&lt;/p&gt;
&lt;h3 id=&#34;5-按需加载&#34;&gt;5 按需加载&lt;/h3&gt;
&lt;p&gt;使用 scrollview 的代理方法进行判断, 当 tableview 静止或者滑动减速的时候进行异步加载,之家在目标范围内的 cell; 减少了无关的性能损耗;&lt;/p&gt;
&lt;h3 id=&#34;6-减少动态添加-subviews&#34;&gt;6 减少动态添加 subviews&lt;/h3&gt;
&lt;h3 id=&#34;7-减少-cell-子视图的绘制&#34;&gt;7 减少 cell 子视图的绘制&lt;/h3&gt;
</description>
        </item>
        <item>
        <title>iOS之UIAppearance</title>
        <link>http://47.99.84.217/post/ios%E4%B9%8Buiappearance/</link>
        <pubDate>Tue, 17 Apr 2018 15:18:13 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios%E4%B9%8Buiappearance/</guid>
        <description>&lt;p&gt;UIAppearance是苹果在iOS5之后为开发者提供的一个能够快速修改系统控件外观的一个协议;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIAppearance的作用:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;UIAppearance 实际上是一个协议,可以用它快速的获取一个类的外观(UINavigation UItabBaritem), 我们可以利用需要修改的类获取外观代理,然后自定义一个实例对象的外观;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIAppearance 的使用:&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;我们可以给一个类所有的实例对象设置外观 eg:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-null&#34; data-lang=&#34;null&#34;&gt;+(instancetype)appearance;
// 修改navigation实例对象的颜色和标题外观
UINavigationBar.appearance().titleTextAttributes =
[NSFontAttributeName: [UIFont systemFontofSIze(15.0f)],NSForegroundColorAttributeName: [UIColor whiteColor]];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们也可以给制定一类容器,在这个容器中自定义一个类所有的实例外观 eg:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-null&#34; data-lang=&#34;null&#34;&gt;+ (instancetype)appearanceWhenContainedIn:(nullable Class &amp;lt;UIAppearanceContainer&amp;gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(5_0, 9_0, &amp;#34;Use +appearanceWhenContainedInInstancesOfClasses: instead&amp;#34;) __TVOS_PROHIBITED;
//修改导航栏所有外观的外观, 可以放置多个容器类
[[UIBarButtonItem appearanceWhenContainedIn:self.nil] set
BackgroundImage: myNavBarButtonBackgroundImage forState:state barMetrics:metrics];
[[UIBArBUttonItem appearanceWhenContainedIn:self,[UIPopoverControll class],nil] setBackgroundColor: myNavBarButtonBackgroundImage forState:state barMetrics:metrics];
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>iOS奇巧淫技</title>
        <link>http://47.99.84.217/post/ios%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/</link>
        <pubDate>Tue, 17 Apr 2018 15:17:50 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/</guid>
        <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改UITextField文本输入框中的clearButton小图片 // 获取X按钮 UIButton *passwordBtn = [_passwordField valueForKey:@&amp;quot;_clearButton&amp;quot;]; // 修改按钮图片 [passwordBtn setImage:[UIImage imageNamed:@&amp;ldquo;login_checkbox_checked&amp;rdquo;] forState:UIControlStateNormal]; UIButton *accountBtn = [_accountField valueForKey:@&amp;quot;_clearButton&amp;quot;]; [accountBtn setImage:[UIImage imageNamed:@&amp;ldquo;login_checkbox_checked&amp;rdquo;] forState:UIControlStateNormal];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tableview不想显示没有内容的cell&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;self.tableview.tablefooterview = [UIView new];&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义了leftBarbuttonItem左滑返回手势失效了怎么办? self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(onBack:)]; self.navigationController.interactivePopGestureRecognizer.delegate = (id)self;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;ScrollView在viewController终不能滑到顶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;self.automaticallyAdjustsScrollViewInsets = NO;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写键盘事件让你不爽了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;github搜索 IQKeyboardManger&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎么在不新建一个cell的情况下调整separaLine的位置?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;self.tableview.separatorinset = UIEdgeInsetMake(0,100,0,0)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击self.view 就收起键盘
&lt;ul&gt;
&lt;li&gt;(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [self.view endEditing:YES]; }&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;滑动的时候隐藏navigationbar?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;navigationController.hidesBarsonSwipe = YES&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ViewController 实现tableview那种悬停header&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSStickyHeaderFlowLayout&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CoreData用来不爽?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MagicalRecord&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改UITextField placeholder的文字颜色&amp;amp;位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void) drawPlaceholderInRect:(CGRect)rect {&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[[UIColor blueColor] setFill]; [self.placeholder drawInRect:rect withFont:self.font lineBreakMode:UILineBreakModeTailTruncation alignment:self.textAlignment]; }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;navigationbar弄成透明的而不是带模糊的效果? [self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationBar.shadowImage = [UIImage new]; self.navigationBar.translucent = YES;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改tableview里面cell的小对勾颜色&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tableview.tintcolor = [uicolor redcolor]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用一个pan手势来代替UISwipegesture各个方向&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)pan:(UIPanGestureRecognizer *)sender {&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;typedef NS_ENUM(NSUInteger, UIPanGestureRecognizerDirection) { UIPanGestureRecognizerDirectionUndefined, UIPanGestureRecognizerDirectionUp, UIPanGestureRecognizerDirectionDown, UIPanGestureRecognizerDirectionLeft, UIPanGestureRecognizerDirectionRight }; static UIPanGestureRecognizerDirection direction = UIPanGestureRecognizerDirectionUndefined; switch (sender.state) {&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-null&#34; data-lang=&#34;null&#34;&gt;case UIGestureRecognizerStateBegan: {
    if (direction == UIPanGestureRecognizerDirectionUndefined) {
        CGPoint velocity = [sender velocityInView:recognizer.view];
        BOOL isVerticalGesture = fabs(velocity.y) &amp;gt; fabs(velocity.x);
        if (isVerticalGesture) {
            if (velocity.y &amp;gt; 0) {
                direction = UIPanGestureRecognizerDirectionDown;
            } else {
                direction = UIPanGestureRecognizerDirectionUp;
            }
        }
        else {
            if (velocity.x &amp;gt; 0) {
                direction = UIPanGestureRecognizerDirectionRight;
            } else {
                direction = UIPanGestureRecognizerDirectionLeft;
            }
        }
    }
    break;
}
case UIGestureRecognizerStateChanged: {
    switch (direction) {
        case UIPanGestureRecognizerDirectionUp: {
            [self handleUpwardsGesture:sender];
            break;
        }
        case UIPanGestureRecognizerDirectionDown: {
            [self handleDownwardsGesture:sender];
            break;
        }
        case UIPanGestureRecognizerDirectionLeft: {
            [self handleLeftGesture:sender];
            break;
        }
        case UIPanGestureRecognizerDirectionRight: {
            [self handleRightGesture:sender];
            break;
        }
        default: {
            break;
        }
    }
    break;
}
case UIGestureRecognizerStateEnded: {
    direction = UIPanGestureRecognizerDirectionUndefined;
    break;
}
default:
    break;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;} }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片拉伸&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Storyboard或xib中拖入的控件都有Stretching属性，包含四个参数：X、Y、Width、Height。这些参数确定了进行拉伸的区域。 当X = Y = Width = Height = 1时，图片为原始大小。 若让X = Y = 0.5、Width = Height = 0，则按水平垂直位置的那个像素点进行拉伸，如图所示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改UISearchBar 的占位符文字颜色 /&lt;strong&gt;设置UISearchBar&lt;/strong&gt;/ // 创建 UISearchBar *searchBar = [[UISearchBar alloc] init]; // 设置导航条背景色 self.navigationController.navigationBar.barTintColor = [UIColor hollyGreenColor]; // 风格 searchBar.searchBarStyle = UISearchBarStyleMinimal; // 光标色 searchBar.tintColor = [UIColor whiteColor]; // 占位文字 searchBar.placeholder = @&amp;ldquo;搜索&amp;rdquo;; // 设置占位文字色彩 UITextField *searchField = [searchBar valueForKey:@&amp;ldquo;searchField&amp;rdquo;];&lt;/p&gt;
&lt;p&gt;[searchField setValue:[UIColor whiteColor] forKeyPath:@&amp;quot;_placeholderLabel.textColor&amp;quot;];&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>运用runtime扩大UIButton的响应区域</title>
        <link>http://47.99.84.217/post/%E8%BF%90%E7%94%A8runtime%E6%89%A9%E5%A4%A7uibutton%E7%9A%84%E5%93%8D%E5%BA%94%E5%8C%BA%E5%9F%9F/</link>
        <pubDate>Tue, 17 Apr 2018 15:00:47 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E8%BF%90%E7%94%A8runtime%E6%89%A9%E5%A4%A7uibutton%E7%9A%84%E5%93%8D%E5%BA%94%E5%8C%BA%E5%9F%9F/</guid>
        <description>&lt;p&gt;在日常开发中, 设计师有时候会设计一个看起来小小的按钮, 用户很难点击到这个按钮; 为了解决这个问题,简单粗暴的就是将 button 的 frame 放大, 分别调整button的 frame 和显示内容的 frame ,即麻烦,又显得怪异;如果我们使用 runtime 关联对象的方法对 button 进行扩展,去扩大 UIButton 的可交互区域,这样会更好一点&lt;/p&gt;
&lt;p&gt;其执行原理为：OC中创建类别(Categroy)的方式，并不允许给已有的类扩展属性，只可以给其扩展方法。所以，需要使用Runtime“黑魔法”中的关联对象(Associative Object)的一些方法，动态地为某个button对象添加扩展距离的属性，然后检测UITouch事件的触摸点是否在我们扩展距离后Rect内，从而达到想要的效果。&lt;/p&gt;
&lt;p&gt;首先，创建一个UIButton的Category，起名为EnlargeTouchArea，设置一个外界可访问的方法setEnlaEdgeWithTop:right:bottom:left，在使用时也只需使用这个方法即可，传入的四个参数分别是上、右、下、左的扩展距离。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//  UIButton+EnlargeTouchArea.h
#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;UIKit/UIKit.h&amp;gt;
@interface UIButton (EnlargeTouchArea)
- (void)setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left;
@end
    然后导入&amp;lt;objc/runtime.h&amp;gt;，所有Runtime的黑魔法都在这里
//  UIButton+EnlargeTouchArea.m
#import &amp;#34;UIButton+EnlargeTouchArea.h&amp;#34;
#import &amp;lt;objc/runtime.h&amp;gt;
@implementation UIButton (EnlargeTouchArea)
static char topNameKey;
static char rightNameKey;
static char bottomNameKey;
static char leftNameKey;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;objc_setAssociatedObject是一个C语言函数，这个函数被称之为“关联API”，它的作用是把top、right、bottom、left这四个从外界获取到的值与本类(self)关联起来，然后设置一个static char作为能够找到他们的Key&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (void) setEnlargeEdgeWithTop:(CGFloat) top right:(CGFloat) right bottom:(CGFloat) bottom left:(CGFloat) left
{
    objc_setAssociatedObject(self, &amp;amp;topNameKey, [NSNumber numberWithFloat:top], OBJC_ASSOCIATION_COPY_NONATOMIC);
    objc_setAssociatedObject(self, &amp;amp;rightNameKey, [NSNumber numberWithFloat:right], OBJC_ASSOCIATION_COPY_NONATOMIC);
    objc_setAssociatedObject(self, &amp;amp;bottomNameKey, [NSNumber numberWithFloat:bottom], OBJC_ASSOCIATION_COPY_NONATOMIC);
    objc_setAssociatedObject(self, &amp;amp;leftNameKey, [NSNumber numberWithFloat:left], OBJC_ASSOCIATION_COPY_NONATOMIC);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;bjc_getAssociatedObject同样也是一个关联API(c语言函数)，它可以通过刚刚设置的Key找到上个方法中从外界传入的top、right、bottom、left，这个api和obj_setAssociatedObject一起使用就可以达到给已有类扩展属性的效果。最后我们通过self.bounds设置一个新的CGRect，作为扩大后的点按区域，并且返回&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- (CGRect) enlargedRect
{
    NSNumber* topEdge = objc_getAssociatedObject(self, &amp;amp;topNameKey);
    NSNumber* rightEdge = objc_getAssociatedObject(self, &amp;amp;rightNameKey);
    NSNumber* bottomEdge = objc_getAssociatedObject(self, &amp;amp;bottomNameKey);
    NSNumber* leftEdge = objc_getAssociatedObject(self, &amp;amp;leftNameKey);
    if (topEdge &amp;amp;&amp;amp; rightEdge &amp;amp;&amp;amp; bottomEdge &amp;amp;&amp;amp; leftEdge)
    {
        return CGRectMake(self.bounds.origin.x - leftEdge.floatValue,
                          self.bounds.origin.y - topEdge.floatValue,
                          self.bounds.size.width + leftEdge.floatValue + rightEdge.floatValue,
                          self.bounds.size.height + topEdge.floatValue + bottomEdge.floatValue);
    }
    else
    {
        return self.bounds;
    }
}
   这个方法UIView的一个实例方法，作用是，捕获当前的UITouch事件中的触摸点，检测它是否在最上层的子视图内，如果不是的话就递归检测其父视图。这样的话，我们就只是将当前某一个触摸的point与某一个rect进行比较，并没有改变Button真实的frame，从而真正的从逻辑上达到了只是扩大点按区域的效果。
1. - (UIView) hitTest:(CGPoint) point withEvent:(UIEvent) event
2. {
3.     CGRect rect = [self enlargedRect];
4.     if (CGRectEqualToRect(rect, self.bounds))
5.     {
6.         return [super hitTest:point withEvent:event];
7.     }
8.     return CGRectContainsPoint(rect, point) ? self : nil;
9. }
    总结一下，为什么要用runtime去为已有类达到一个扩展属性的效果呢，正是因为上面这个方法，这个系统提供的方法并没有提供接受其他参数的地方，而我们却必须要指定一个扩大的区域作为参数，所以就必须为这个类扩展一个新的属性。
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>iOS设计模式之单例</title>
        <link>http://47.99.84.217/post/ios%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B/</link>
        <pubDate>Tue, 17 Apr 2018 14:45:14 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B/</guid>
        <description>&lt;p&gt;单例模式的意思就是这个类只有一个实例，这个类就是单例类。在iOS中有不少都是单例NSNull，NSFileManager ，UIApplication，NSUserDefaults ，UIDevice，还有一些第三方也有能用到了这种设计模式例如Afhttpmanger。。。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;（1）单例模式的作用 :可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源。 （2）单例模式的使用场合：在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次），应该让这个类创建出来的对象永远只有一个。 实现思路： 创建一个一个全局的static的实例 static id _instance; 提供1个类方法让外界访问唯一的实例 重写allocWithzone:方法，控制内存分配。因为alloc内部会调用该方法，每次调用allocWithzone:方法，系统都会创建一块新的内存空间。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 实现copyWithZone:方法 
// AudioPlayer.m 
// 单例 
// 
// Created by 两好三坏 on 16/2/21. 
// Copyright © 2016年 ;. All rights reserved. 
// 
#import &amp;amp;amp;quot;AudioPlayer.h&amp;amp;amp;quot; 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;@interface&amp;lt;/spanAudioPlayer&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt; () 
@end 
@implementation&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;s4&amp;#34;&amp;gt;AudioPlayer 
//创建一个一个全局的static的实例 static id _instance; 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;static&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;id&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _instance; 
//提供1个类方法让外界访问唯一的实例 
+(instancetype)shareAudioPlayer{ 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;static&amp;lt;/spandispatch_once_t&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt; onceToken; 
&amp;gt; &amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;dispatch_once&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;(&amp;amp;amp;amp;onceToken, ^{ 
_instance = [[&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;self&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; alloc] init]; 
}); 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;return&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _instance; 
} 
//重写allocWithzone:方法，控制内存分配。因为alloc内部会调用该方法，每次调用allocWithzone:方法，系统都会创建一块新的内存空间。 
+(instancetype)allocWithZone:(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;struct&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;NSZone&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; *)zone{ 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;static&amp;lt;/spandispatch_once_t&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt; onceToken; 
&amp;gt; &amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;dispatch_once&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;(&amp;amp;amp;amp;onceToken, ^{ 
_instance = [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;super&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; allocWithZone:zone]; 
}); 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;return&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _instance; 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;} 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;//实现copyWithZone:方法 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;-(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;id&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;)copyWithZone:(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;NSZone&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; *)zone{ 
&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;return&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _instance; 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;} 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;@end 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;在控制其中创建单例类的对象，打印地址： 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;- (&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;void&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;)viewDidLoad { 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;super&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; viewDidLoad]; 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;AudioPlayer *player1 = [AudioPlayer shareAudioPlayer]; 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;AudioPlayer *player2 = [[AudioPlayer alloc] init]; 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;AudioPlayer *player3 = [AudioPlayer new]; 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;AudioPlayer *player4 = [player1 &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;copy&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;]; 
&amp;gt; &amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;NSLog&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;(@&amp;amp;amp;quot;%p,%p,%p,%p&amp;amp;amp;quot;,player1,player2,player3,player4); 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;} 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;//打印结果 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;2016&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;-&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;02&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;-&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;21&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;23&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;:&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;27&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;:&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;13.990&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt; 单例[&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;2847&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;:&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;329685&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;] &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;0x7fb6e3e080a0&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;0x7fb6e3e080a0&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;0x7fb6e3e080a0&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s3&amp;#34;&amp;gt;,&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;0x7fb6e3e080a0 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;四个实例的内存地址是一样的，证明只创建了一个实例； 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;MRC环境下通常需要在实现下面几个方法： 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;- (&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;oneway&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;void&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;)release {} 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;- (&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;id&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;)retain { &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;return&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _instance; } 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;- (&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;id&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;)autorelease { &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;return&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt; _instance; } 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;- (&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;NSUInteger&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;)retainCount { &amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s2&amp;#34;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;s5&amp;#34;&amp;gt;UINT_MAX&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;; } 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;[/objc] 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;可以使用宏判断是否为mrc， 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;#if __has_feature(objc_arc) 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;// ARC 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;#else 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;// MRC 
&amp;gt; &amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;#endif 
&amp;gt; &amp;amp;nbsp;
&amp;lt;span class=&amp;#34;s1&amp;#34;&amp;gt;当然还可以把单例也抽取成为宏，用起来还挺方便的；你们也可以试试试～～～&amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>iOS 界面传值</title>
        <link>http://47.99.84.217/post/ios-%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC/</link>
        <pubDate>Tue, 17 Apr 2018 14:43:55 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ios-%E7%95%8C%E9%9D%A2%E4%BC%A0%E5%80%BC/</guid>
        <description>&lt;p&gt;在iOS开发新中经常会遇到在两个界面之间进行传值的情况,在页面之间进行数据传递有正向传递(控制器A跳转到控制器B),也有反向传值(控制器B跳转到A).可以通过属性,代理,block,通知等等. 就解释一下怎么使用block和代理进行页面之间反向传值;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;使用block进行反向传值 在Xcode中创建新的项目 创建两个控制器A,B. 在A控制器中添加一个按钮,对按钮添加点击跳转到B控制器,然后再A中再次添加一个label,作为接受B控制器中传回来的值. 在B控制器中创建一个UITextField,用于输入信息. 在A控制器中.m文件中代码如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//
// ViewController.m
// 反向传值
//
// Created by 两好三坏 on 16/3/3.
// Copyright © 2016年 qinakun. All rights reserved.
//
import &amp;#34;ViewController.h&amp;#34;
使用block传值的控制器
import &amp;#34;BlockVC.h&amp;#34;
使用delegate传值的控制器
import &amp;#34;DelegateVC.h&amp;#34;
@interface ViewController ()
//用于接受数据的label
@property (weak, nonatomic) IBOutlet UILabel *inputLabel;
@end
@implementation ViewController
- (void)viewDidLoad {
  [super viewDidLoad];
  }
//跳转控制器的
- (IBAction)jumpVC:(id)sender {
  //调用block进行传值
  // [self block];
  //调用bdelegate进行传值
  [self delegate];
  }
//使用block进行反向传值
-(void)block{
UIStoryboard *sb = [UIStoryboard storyboardWithName:@&amp;#34;BlockSB&amp;#34; bundle:nil];
BlockVC *blockVc = [sb instantiateViewControllerWithIdentifier:@&amp;#34;blockVC&amp;#34;];
//inputBlock是定义好的block
[blockVc setInputBlock:^(NSString *string) {
//在这里对A控制器的label进行设置,这个string参数是从B控制器中传过来的;
self.inputLabel.text = string;
}];
[self.navigationController pushViewController:blockVc animated:YES];
}
//使用delegate进行反向传值
-(void)delegate{
DelegateVC *vc = [DelegateVC new];
//需要让控制器A成为控制器B的代理.
vc.delegate = self;
[self.navigationController pushViewController:vc animated:YES];
}
//代理方法中给input进行传值
-(void)changeValue:(NSString *)string{
self.inputLabel.text = string;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来是在控制器B中定义一个ｂｌｏｃｋ的代码块，这个block的参数是字符串,在控制器B的.h文件中声明如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@property (nonatomic, copy) void (^inputBlock)(NSString *string);
控制器B的.m文件代码如下:
import &amp;#34;BlockVC.h&amp;#34;
@interface BlockVC ()
@property (weak, nonatomic) IBOutlet UITextView *input;
@end
@implementation BlockVC
- (void)viewDidLoad {
  [super viewDidLoad];
  }
  //点击屏幕是输入框失去第一响应者的资格
  -(void)touchesBegan:(NSSet _)touches withEvent:(UIEvent _)event{
[self.input resignFirstResponder];
}
//在控制器即将消失的时候调用,
-(void)viewWillDisappear:(BOOL)animated{
[super viewWillDisappear:animated];
//取到输入框的内容保存在代码块中,在需要的时候将参数传给控制器A
if (self.inputBlock) {
self.inputBlock (self.input.text);
}
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就算完成了一个简单的在两个页面之间进行反向传值的功能. 使用delegate进行反向传值 代理应用场景及使用步骤 对象A内部发生了一些事情,想通知对象B 对象B想监听对象A内部发生了什么事情 对象A想在自己的方法内部调用对象B的某个方法,并且对象A不能对对象B有耦合依赖 对象A想传递数据给对象B 以上情况,结果都一样:对象B是对象A的代理(delegate) 1.先搞清楚谁是谁的代理(delegate) 2.定义代理协议,协议名称的命名规范:控件类名 + Delegate 3.定义代理方法 代理方法一般都定义为@optional 代理方法名都以控件名开头 代理方法至少有1个参数,将控件本身传递出去 设置代理(delegate)对象 (比如myView.delegate = xxxx;) 代理对象遵守协议 代理对象实现协议里面该实现的方法 在恰当的时刻调用代理对象(delegate)的代理方法,通知代理发生了什么事情 (在调用之前判断代理是否实现了该代理方法) 这是代理的使用场景以及使用步骤,下面是使用delegate实现前面block实现的功能 假如控制器C想利用代理给控制器A传值,那么 控制器C要有一个协议 控制器要有一个代理属性 控制器A遵守C的代理协议,并且成为C的代理对象. 控制器C的.h文件中作出如下声明:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//
// DelegateVC.h
// 反向传值
//
// Created by 两好三坏 on 16/3/5.
// Copyright © 2016年 qinakun. All rights reserved.
//
import UIKit/UIKit.h
@class DelegateVC;
//协议
@protocol DelegateVCDelegate
//A需要实现的代理方法
-(void)changeValue:(NSString *)string;
@end
@interface DelegateVC : UIViewController
//代理属性
@property(nonatomic,weak) iddelegate;
@end
[/objc]
然后在.m文件中代码:
[objc]
//
// DelegateVC.m
// 反向传值
//
// Created by 两好三坏 on 16/3/5.
// Copyright © 2016年 qinakun. All rights reserved.
//
import &amp;#34;DelegateVC.h&amp;#34;
define kWidth [UIScreen mainScreen].bounds.size.width
define kHeight [UIScreen mainScreen].bounds.size.height
@interface DelegateVC ()
@property(nonatomic,strong) UITextField *textValue;
@end
@implementation DelegateVC
- (void)viewDidLoad {
  [super viewDidLoad];
  self.view.backgroundColor = [UIColor whiteColor];
  创建一个输入框,添加到控制器C的view上;
  UITextField _tf = [[UITextField alloc] init];
  tf.backgroundColor = [UIColor grayColor];
  tf.frame = CGRectMake(kWidth _0.5 - 50, kHeight * 0.5, 100, 40);
self.textValue = tf;
[self.view addSubview:_textValue];
}
//当控制器C消失的时候调用的方法
-(void)viewWillDisappear:(BOOL)animated{
[super viewWillDisappear:animated];
//如果有对象响应了代理,就执行if判断中的方法,
if ([self.delegate respondsToSelector:@selector(changeValue:)]) {
//把输入框中的text取出来作为代理方法的参数传送给控制器A
[self.delegate changeValue:self.textValue.text];
}
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在页面中传值得方法有很多,使用通知,KVO,单例,还有偏好设置,归档解档都可以实现,看情况哪个方便就是用哪个咯….&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
