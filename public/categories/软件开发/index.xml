<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>软件开发 on 煎人寿</title>
        <link>http://47.99.84.217/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
        <description>Recent content in 软件开发 on 煎人寿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Thu, 16 Mar 2023 15:18:02 +0800</lastBuildDate><atom:link href="http://47.99.84.217/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>使用Flutter创建樱花落下动画</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8flutter%E5%88%9B%E5%BB%BA%E6%A8%B1%E8%8A%B1%E8%90%BD%E4%B8%8B%E5%8A%A8%E7%94%BB/</link>
        <pubDate>Thu, 16 Mar 2023 15:18:02 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8flutter%E5%88%9B%E5%BB%BA%E6%A8%B1%E8%8A%B1%E8%90%BD%E4%B8%8B%E5%8A%A8%E7%94%BB/</guid>
        <description>&lt;p&gt;在本篇博客中，我们将学习如何使用 Flutter 制作一个樱花落下的动画效果。我们将实现一个简单的樱花落下动画，并加入微风效果以及淡入淡出效果。我们的最终目标是让樱花以不同的速度和初始位置落下，并在屏幕上按照一定的轨迹随微风飘动。
&lt;img src=&#34;https://img.52smile.vip/1678950904.gif&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678950904.gif&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;开始之前
确保你已经安装了 Flutter 开发环境。本教程适用于具有一定 Flutter 基础知识的开发者。&lt;/p&gt;
&lt;h3 id=&#34;创建动画&#34;&gt;创建动画&lt;/h3&gt;
&lt;p&gt;首先，我们需要创建一个 StatefulWidget，因为我们需要使用动画控制器。接下来，我们在 State 类中使用 SingleTickerProviderStateMixin 来创建 AnimationController。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class FallingLeavesAnimation extends StatefulWidget {
  @override
  _FallingLeavesAnimationState createState() =&amp;gt; _FallingLeavesAnimationState();
}

class _FallingLeavesAnimationState extends State&amp;lt;FallingLeavesAnimation&amp;gt;
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  final _leaves = List.generate(20, (index) =&amp;gt; Leaf());

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(seconds: 15),
      vsync: this,
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们创建了一个 _controller，并设置动画持续时间为 15 秒。然后调用 repeat() 方法，让动画循环播放。&lt;/p&gt;
&lt;h3 id=&#34;美化动画&#34;&gt;美化动画&lt;/h3&gt;
&lt;p&gt;接下来，我们创建一个 Leaf 类来生成随机的初始位置、速度和旋转角度。这将使动画看起来更自然。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
class Leaf {
  final double startX;
  final double startY;
  final double speedX;
  final double speedY;
  final double rotation;

  Leaf()
      : startX = Random().nextDouble() * 300,
        startY = -Random().nextDouble() * 300,
        speedX = 20 + Random().nextDouble() * 50,
        speedY = 50 + Random().nextDouble() * 100,
        rotation = Random().nextDouble() * 4 * pi;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;执行动画并更新&#34;&gt;执行动画并更新&lt;/h3&gt;
&lt;p&gt;现在，我们将使用 AnimatedBuilder 在 build 方法中创建动画效果。在每次 build 方法调用时，动画进度会被更新，根据动画进度计算樱花的位置、旋转角度和透明度。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(
      title: const Text(&amp;#39;Falling Leaves Animation with Breeze&amp;#39;),
    ),
    body: Stack(
      children: [
        for (final leaf in _leaves)
          AnimatedBuilder(
            animation: _controller,
            builder: (context, child) {
              final progress = _controller.value;
              final screenWidth =MediaQuery.of(context).size.width;
          final screenHeight = MediaQuery.of(context).size.height;
          final breeze = 50 * sin(2 * pi * progress);
          final leafX = leaf.startX + leaf.speedX * progress + breeze;
          final leafY = leaf.startY +
              leaf.speedY * progress +
              0.5 * 9.8 * pow(progress, 2);
          final rotation = leaf.rotation * progress;
          final opacity = (1 - progress) * (1 - progress);
          return Positioned(
            left: leafX,
            top: leafY % screenHeight,
            child: Transform.rotate(
              angle: rotation,
              child: Opacity(
                  opacity: opacity,
                child: SvgPicture.asset(
                  &amp;#39;assets/cherry_blossom.svg&amp;#39;,
                  width: 25,
                  height: 25,
                ),
              ),
            ),
          );
        },
      ),
  ],
),
);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用了 &lt;code&gt;Stack&lt;/code&gt; 组件来确保樱花动画可以覆盖在其他组件上。然后，我们使用 &lt;code&gt;for&lt;/code&gt; 循环遍历 &lt;code&gt;_leaves&lt;/code&gt; 列表中的每个 &lt;code&gt;Leaf&lt;/code&gt; 对象，并使用 &lt;code&gt;AnimatedBuilder&lt;/code&gt; 更新动画效果。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;builder&lt;/code&gt; 函数中，我们首先获取动画的进度值 &lt;code&gt;_controller.value&lt;/code&gt;，然后计算屏幕的宽度和高度。我们使用正弦函数创建一个微风效果，使樱花在水平方向上随风飘动。接着，我们根据 &lt;code&gt;Leaf&lt;/code&gt; 对象的初始位置和速度以及动画进度来计算樱花的当前位置和旋转角度。&lt;/p&gt;
&lt;p&gt;为了使樱花在落下过程中逐渐消失，我们计算透明度值 &lt;code&gt;opacity&lt;/code&gt;。最后，我们使用 &lt;code&gt;Positioned&lt;/code&gt; 组件来设置樱花的位置，并使用 &lt;code&gt;Transform.rotate&lt;/code&gt; 组件来设置旋转角度。为了实现淡入淡出效果，我们使用 &lt;code&gt;Opacity&lt;/code&gt; 组件来设置樱花的透明度。&lt;/p&gt;
&lt;h3 id=&#34;代码地址&#34;&gt;代码地址&lt;/h3&gt;
&lt;p&gt;相关的代码实现你可以在这里找到: &lt;a class=&#34;link&#34; href=&#34;https://github.com/oooldCaption/flutter_blog/blob/main/lib/2023_03/leaf_fall_anim.dart&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;git_repo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;在本教程中，我们学习了如何使用 Flutter 制作一个樱花落下的动画效果，包括微风效果和淡入淡出效果。我们了解了如何使用 &lt;code&gt;AnimationController&lt;/code&gt; 控制动画进度，以及如何使用 &lt;code&gt;AnimatedBuilder&lt;/code&gt; 更新动画效果。希望本教程对你有所帮助，祝你在 Flutter 开发中取得更多进步！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Python修改音频文件元信息</title>
        <link>http://47.99.84.217/post/python%E4%BF%AE%E6%94%B9%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%85%83%E4%BF%A1%E6%81%AF/</link>
        <pubDate>Sat, 03 Dec 2022 21:44:50 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/python%E4%BF%AE%E6%94%B9%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%85%83%E4%BF%A1%E6%81%AF/</guid>
        <description>&lt;p&gt;事情是这样的&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;巴拉巴拉巴拉巴拉巴拉巴拉&lt;/p&gt;
&lt;p&gt;巴拉巴拉巴拉巴拉巴拉巴拉&lt;/p&gt;
&lt;p&gt;巴拉巴拉巴拉巴拉巴拉巴拉&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;
&lt;p&gt;我下载了一个 MP3 版本的&amp;lt;&lt;strong&gt;天龙八部&lt;/strong&gt;&amp;gt;想着上下班通勤的时候听, 结果导入到本地播放器(EverPlayer)的时候发现播放顺序是乱的.&lt;/p&gt;
&lt;p&gt;这样的话可能剧情上就会断断续续, 听起来有点前言不搭后语的, 毕竟不是按照播讲顺序听的.&lt;/p&gt;
&lt;p&gt;本来我想应该是因为文件名读取的问题,  因为文件名格式并不是按照&lt;code&gt; 01 , 02,  03.... 33, 34&lt;/code&gt;这种顺序排列的, 所以写了一个小脚本, 用来序列化文件名, 保证文件名是 从 &lt;code&gt;1,2,3....32,33,34&lt;/code&gt; 这样的逻辑顺序. 然后重新新导入到播放器, 发现还是不对.&lt;/p&gt;
&lt;p&gt;认真打量了一眼播放器的页面信息, 发现排序根据音频文件的元数据信息进行排序的. 找到了问题的所在, 我们就可以解决这个问题啦.&lt;/p&gt;
&lt;h3 id=&#34;为什么要修改音频文件的元数据标签&#34;&gt;为什么要修改音频文件的元数据标签&lt;/h3&gt;
&lt;p&gt;举个🌰:&lt;/p&gt;
&lt;p&gt;我现在有一个 mp3 文件, 文件名叫做, &lt;code&gt;001 青衫磊落险峰行1.mp3&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt;在电脑中, 我们可以查看文件的详细信息, 如图所示:
可以看到, 在红色方框中显示标题是 vx 听书, 但是文件名却是带序列号的文件名, 因为有些音频播放器会读取 标题 , 来当做歌曲名, 而不是将文件名作为歌曲名的读取对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/1678871232.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678871232.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以按照以下的方式来读取 &lt;code&gt;mp3&lt;/code&gt; 文件的 &lt;code&gt;标签&lt;/code&gt;  或者 &lt;code&gt;元数据&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from mutagen.id3 import ID3, TIT1, TIT2

name = &amp;#34;001青衫磊落险峰行1.mp3&amp;#34;
def read_mp3():
    audio = ID3(name)
    for tag in audio.keys():
        print(tag + &amp;#34;: &amp;#34; + str(audio.get(tag)))

read_mp3()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行之后你会在控制台看到如下输出结果, 结果中包含云数据标签的 &lt;strong&gt;标签名&lt;/strong&gt; &lt;code&gt;(eg:TIT2)&lt;/code&gt; 和 &lt;strong&gt;标签对应的值&lt;/strong&gt; &lt;code&gt;(eg: vx听书)&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TIT2: vx听书
TPE1: 唯一拼课微信：****
TALB: 唯一拼课微信：****
TCOM: 唯一拼课微信：****
TPE2: 唯一拼课微信：****
COMM::eng: 唯一拼课微信：****
COMM:ID3v1 Comment:eng: ****
APIC:: APIC(encoding=&amp;lt;Encoding.LATIN1: 0&amp;gt;, mime=&amp;#39;image/jpeg&amp;#39;, type=&amp;lt;PictureType.COVER_FRONT: 3&amp;gt;, desc=&amp;#39;&amp;#39;, data=b&amp;#39;...&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们要做的就是 去弄明白 这些标签名 对应的是什么意思, 这个你可以在相关第三方的 api 文档中得到答案,  我在下面将 mp3 类型的文件做了一下统计和整理, 列表如下:&lt;/p&gt;
&lt;h3 id=&#34;mp3-格式标签属性列表&#34;&gt;MP3 格式标签属性列表&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;APIC&lt;/td&gt;
&lt;td&gt;封面图像，包括图片类型、描述、二进制数据等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMM&lt;/td&gt;
&lt;td&gt;评论，包括语言、评论文本等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TALB&lt;/td&gt;
&lt;td&gt;专辑名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TBPM&lt;/td&gt;
&lt;td&gt;每分钟节拍数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCOM&lt;/td&gt;
&lt;td&gt;作曲家。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCON&lt;/td&gt;
&lt;td&gt;音频类型，如流行、摇滚、古典等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TCOP&lt;/td&gt;
&lt;td&gt;版权信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TDAT&lt;/td&gt;
&lt;td&gt;日期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TDRC&lt;/td&gt;
&lt;td&gt;录制日期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TENC&lt;/td&gt;
&lt;td&gt;编码器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TEXT&lt;/td&gt;
&lt;td&gt;作词家。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TFLT&lt;/td&gt;
&lt;td&gt;文件类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIT1&lt;/td&gt;
&lt;td&gt;内容组描述。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIT2&lt;/td&gt;
&lt;td&gt;歌曲名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIT3&lt;/td&gt;
&lt;td&gt;副标题。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TLEN&lt;/td&gt;
&lt;td&gt;音频长度。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TMED&lt;/td&gt;
&lt;td&gt;媒体类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TOAL&lt;/td&gt;
&lt;td&gt;原始专辑/电影/节目名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TOFN&lt;/td&gt;
&lt;td&gt;原始文件名。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TOLY&lt;/td&gt;
&lt;td&gt;原始歌词作者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TOPE&lt;/td&gt;
&lt;td&gt;原始表演者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TORY&lt;/td&gt;
&lt;td&gt;原始发行年份。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TOWN&lt;/td&gt;
&lt;td&gt;文件所有者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TPE1&lt;/td&gt;
&lt;td&gt;艺术家。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TPE2&lt;/td&gt;
&lt;td&gt;乐队。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TPE3&lt;/td&gt;
&lt;td&gt;指挥者/演奏团体。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TPE4&lt;/td&gt;
&lt;td&gt;翻译/修改者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TPOS&lt;/td&gt;
&lt;td&gt;作品集部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TPUB&lt;/td&gt;
&lt;td&gt;出版者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRCK&lt;/td&gt;
&lt;td&gt;曲目号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRDA&lt;/td&gt;
&lt;td&gt;录制日期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRSN&lt;/td&gt;
&lt;td&gt;Internet电台名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRSO&lt;/td&gt;
&lt;td&gt;Internet电台所有者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TSIZ&lt;/td&gt;
&lt;td&gt;音频大小。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TSRC&lt;/td&gt;
&lt;td&gt;国际标准录音编码(ISRC)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TSSE&lt;/td&gt;
&lt;td&gt;编码器设置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TYER&lt;/td&gt;
&lt;td&gt;年份。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;修改音频文件标签&#34;&gt;修改音频文件标签&lt;/h3&gt;
&lt;p&gt;看完上面那个 长长的表格, 我们就会知道自己有哪些属性是想要修改的, 比如想要在播放的时候, 文件播放序列是从 01 -&amp;gt; 10 的正序进行播放, 我们就可以修改音频文件的 &lt;code&gt;TIT2&lt;/code&gt; 属性为 为你想要播放的序号, 比如修改如下 :&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;001青衫磊落险峰行1.MP3  TIT2 ---&amp;gt;  01
001青衫磊落险峰行2.MP3  TIT2 ---&amp;gt;  02
001青衫磊落险峰行3.MP3  TIT2 ---&amp;gt;  03
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在代码里面可以使用如下方式进行修改:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from mutagen.id3 import ID3, TIT1, TIT2

name = &amp;#34;001青衫磊落险峰行1.mp3&amp;#34;
def mod_mp3():
    audio = ID3(name)
    audio[&amp;#34;TIT2&amp;#34;] = TIT2(encoding=3, text=[&amp;#34;01:青衫磊落险峰行1&amp;#34;]);
    audio.save()
mod_mp3()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种方式, 我们可以修改音频文件所有的原信息, 比如 我给 mp3 添加一个专辑图&lt;/p&gt;
&lt;h3 id=&#34;给-mp3-添加一张图片&#34;&gt;给 mp3 添加一张图片&lt;/h3&gt;
&lt;p&gt;下面的代码提供了一个修改 mp3 文件元数据标签的实例, 修改了 标题, 副标题, 作曲, 以及封面图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/1678927491.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678927491.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
def mod_tag():
    audio = ID3(name)
    with open(&amp;#34;cover.png&amp;#34;, &amp;#34;rb&amp;#34;) as f:
        image_data = BytesIO(f.read())

    apic = APIC(
        encoding=3,  # UTF-8
        mime=&amp;#39;image/png&amp;#39;,
        type=3,  # cover front
        desc=u&amp;#39;Cover&amp;#39;,
        data=image_data.getvalue()
    )
    #修改标题/专辑/作者信息
    audio[&amp;#39;TABL&amp;#39;] = TALB(encoding=3, text=&amp;#34;天龙八部&amp;#34;)
    audio[&amp;#39;TIT2&amp;#39;] = TIT2(encodings = 3, text=&amp;#39;青衫磊落险峰行&amp;#39;)
    audio[&amp;#39;TIT3&amp;#39;] = TIT3(encodings = 3, text=&amp;#39;01&amp;#39;)
    audio[&amp;#39;TCOM&amp;#39;] = TCOM(encodings = 3, text=&amp;#39;金庸&amp;#39;)
    # 修改专辑封面图
    audio[&amp;#39;APIC&amp;#39;] = apic
    audio.save()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改-flac-格式&#34;&gt;修改 FLAC 格式&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from mutagen.flac import FLAC

# 打开FLAC文件
audio = FLAC(&amp;#34;example.flac&amp;#34;)

# 获取元数据信息
title = audio.get(&amp;#34;title&amp;#34;, &amp;#34;Unknown Title&amp;#34;)
artist = audio.get(&amp;#34;artist&amp;#34;, &amp;#34;Unknown Artist&amp;#34;)
album = audio.get(&amp;#34;album&amp;#34;, &amp;#34;Unknown Album&amp;#34;)
bitrate = audio.info.bitrate
length = audio.info.length

# 打印元数据信息
print(&amp;#34;Title:&amp;#34;, title)
print(&amp;#34;Artist:&amp;#34;, artist)
print(&amp;#34;Album:&amp;#34;, album)
print(&amp;#34;Bitrate:&amp;#34;, bitrate)
print(&amp;#34;Length:&amp;#34;, length)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改-ogg-格式&#34;&gt;修改 OGG 格式&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from mutagen.oggvorbis import OggVorbis

# 打开OGG文件
audio = OggVorbis(&amp;#34;example.ogg&amp;#34;)

# 获取元数据信息
title = audio.get(&amp;#34;title&amp;#34;, &amp;#34;Unknown Title&amp;#34;)
artist = audio.get(&amp;#34;artist&amp;#34;, &amp;#34;Unknown Artist&amp;#34;)
album = audio.get(&amp;#34;album&amp;#34;, &amp;#34;Unknown Album&amp;#34;)
bitrate = audio.info.bitrate
length = audio.info.length

# 打印元数据信息
print(&amp;#34;Title:&amp;#34;, title)
print(&amp;#34;Artist:&amp;#34;, artist)
print(&amp;#34;Album:&amp;#34;, album)
print(&amp;#34;Bitrate:&amp;#34;, bitrate)
print(&amp;#34;Length:&amp;#34;, length)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改-wav-格式&#34;&gt;修改 WAV 格式&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from mutagen.oggvorbis import OggVorbis

# 打开OGG文件
audio = OggVorbis(&amp;#34;example.ogg&amp;#34;)

# 获取元数据信息
title = audio.get(&amp;#34;title&amp;#34;, &amp;#34;Unknown Title&amp;#34;)
artist = audio.get(&amp;#34;artist&amp;#34;, &amp;#34;Unknown Artist&amp;#34;)
album = audio.get(&amp;#34;album&amp;#34;, &amp;#34;Unknown Album&amp;#34;)
bitrate = audio.info.bitrate
length = audio.info.length

# 打印元数据信息
print(&amp;#34;Title:&amp;#34;, title)
print(&amp;#34;Artist:&amp;#34;, artist)
print(&amp;#34;Album:&amp;#34;, album)
print(&amp;#34;Bitrate:&amp;#34;, bitrate)
print(&amp;#34;Length:&amp;#34;, length)
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Flutter 渐变</title>
        <link>http://47.99.84.217/post/flutter-%E6%B8%90%E5%8F%98/</link>
        <pubDate>Sun, 20 Nov 2022 17:52:38 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/flutter-%E6%B8%90%E5%8F%98/</guid>
        <description>&lt;p&gt;太久没写技术博客啦~~~~~~~&lt;/p&gt;
&lt;p&gt;最近一直在用&lt;code&gt;fluter&lt;/code&gt;做app,  前几天有个功能需要用渐变色来做一个文本.&lt;/p&gt;
&lt;p&gt;我回想起几年前被我们UI设计师支配的恐惧, 那个UI特别喜欢用渐变色跟圆角, 以至于天天跟CALayer之类的打交道.&lt;/p&gt;
&lt;p&gt;如果想要在flutter上实现渐变色就太简单了, 在&lt;code&gt;Container&lt;/code&gt;容器中有一个修饰器&lt;code&gt;decoration&lt;/code&gt;中 有一个 &lt;code&gt;gradient&lt;/code&gt;属性,  你只要给这个属性设置值, 就可以对容器设置渐变色了.
对修饰器有以下几种创建渐变色的方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinearGradient&lt;/li&gt;
&lt;li&gt;RadialGradient&lt;/li&gt;
&lt;li&gt;SweepGradient&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我会在下面的内容分别对上面这 3 种实现渐变色的方法给出具体的实例和相关代码:&lt;/p&gt;
&lt;h3 id=&#34;lineargradient&#34;&gt;LinearGradient&lt;/h3&gt;
&lt;p&gt;LinearGradient 是 Flutter 中实现线性渐变效果的类，它可以用来创建两个或多个颜色之间的线性渐变。下面是 LinearGradient 的一些适用场景和利弊：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要实现颜色的线性渐变效果，例如从一个颜色平滑过渡到另一个颜色；可以在任何需要使用颜色的地方使用，例如背景、边框、文本等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利弊：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点：简单易用，可以创建平滑过渡的颜色效果，适用于各种需要渐变色的场景。&lt;/p&gt;
&lt;p&gt;缺点：不适合实现复杂的渐变效果，例如径向渐变或多个颜色之间的复杂渐变。对于这种情况，可以考虑使用 RadialGradient 或 SweepGradient 等其他类型的渐变。&lt;/p&gt;
&lt;p&gt;LinearGradient中也有很多其他的属性, 你可以自己尝试一下都有什么效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;：定义渐变的起点位置，它是一个Alignment类型的对象。Alignment类型包含两个属性：x和y，分别表示水平和垂直方向上的偏移量。默认值是Alignment.centerLeft，表示从左到右进行渐变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;：定义渐变的终点位置，也是一个Alignment类型的对象。默认值是Alignment.centerRight，表示从右到左进行渐变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;colors&lt;/code&gt;：定义渐变的颜色数组。渐变将从数组的第一个颜色过渡到最后一个颜色。至少需要提供两个颜色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stops&lt;/code&gt;：定义颜色数组中每个颜色的位置。每个位置的值必须在0.0到1.0之间。如果不提供stops属性，则渐变中每个颜色的位置将均匀分布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tileMode&lt;/code&gt;：定义渐变在超出定义范围时的重复方式。默认值是TileMode.clamp，表示渐变将延伸到起点和终点之外的区域，并使用最近的颜色。模式如下图所示:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&#34;https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;
&lt;img src=&#34;https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LinearGradient 的简单应用, 代码 以及 图例 如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; // LinearGradient
  _linear() {
    return Center(
      child: Container(
          height: 100,
          width: 100,
          decoration: const BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.centerLeft,
              end: Alignment.centerRight,
              colors: [Colors.blue, Colors.black38,Colors.green],
            ),
          ),
          child: Text(&amp;#34;LinearGradient_渐变&amp;#34;) 
          ),
    );
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/1678863878.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678863878.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;以上是LinearGradient的一些重要属性，您可以根据需要进行自定义和扩展，以创建更复杂和有趣的渐变效果。&lt;/p&gt;
&lt;h3 id=&#34;radialgradient&#34;&gt;RadialGradient&lt;/h3&gt;
&lt;p&gt;RadialGradient 是 Flutter 中实现径向渐变效果的类，它可以用来创建从一个中心点向周围扩散的渐变效果。下面是 RadialGradient 的一些适用场景和利弊：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;需要实现从一个中心点向周围扩散的渐变效果，例如圆形背景、圆形边框等；
可以在任何需要使用颜色的地方使用，例如背景、边框、文本等。
利弊：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：可以创建从一个中心点向周围扩散的渐变效果，适用于多种需要径向渐变的场景；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：不适合实现复杂的渐变效果，例如多个颜色之间的复杂渐变。对于这种情况，可以考虑使用 LinearGradient 或 SweepGradient 等其他类型的渐变。&lt;/p&gt;
&lt;p&gt;RadialGradient 属性列表以及说明:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：定义渐变的中心点位置，它是一个Alignment类型的对象。Alignment类型包含两个属性：x和y，分别表示水平和垂直方向上的偏移量。默认值是Alignment.center，表示渐变从中心点开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;radius&lt;/code&gt;：定义渐变的半径，它是一个浮点数，表示从中心点开始的半径。默认值是0.5。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;colors&lt;/code&gt;：定义渐变的颜色数组。渐变将从数组的第一个颜色过渡到最后一个颜色。至少需要提供两个颜色。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stops&lt;/code&gt;：定义颜色数组中每个颜色的位置。每个位置的值必须在0.0到1.0之间。如果不提供stops属性，则渐变中每个颜色的位置将均匀分布。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tileMode&lt;/code&gt;：定义渐变在超出定义范围时的重复方式。默认值是TileMode.clamp，表示渐变将延伸到半径之外的区域，并使用最近的颜色。&lt;/p&gt;
&lt;p&gt;RadialGradient  的简单应用, 代码 以及 图例 如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  _radial() {
    return Center(
      child: Container(
          height: 100,
          width: 100,
          decoration: const BoxDecoration(
            gradient: RadialGradient(
              center: Alignment(0.0, 0.0),
              radius: 0.5,
              colors: [Colors.red, Colors.yellow, Colors.green],
              stops: [0.0, 0.5, 1.0],
              tileMode: TileMode.repeated,
            ),
          ),
          child: Text(&amp;#34;RadialGradient 渐变&amp;#34;)),
    );
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/1678865491.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678865491.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中，我们创建了一个 &lt;code&gt;Container&lt;/code&gt; 组件，并使用 &lt;code&gt;RadialGradient&lt;/code&gt; 作为其背景。我们将渐变的中心点位置设置为&lt;code&gt;Alignment(0.0, 0.0)&lt;/code&gt;，将半径设置为0.5，将颜色数组设置为&lt;code&gt;[Colors.red, Colors.yellow, Colors.green]&lt;/code&gt;，并将停止位置数组设置为&lt;code&gt;[0.0, 0.5, 1.0]&lt;/code&gt;。这意味着渐变将从红色开始，到黄色中间停止，然后到绿色结束。我们还将&lt;code&gt;tileMode&lt;/code&gt;设置为&lt;code&gt;TileMode.repeated&lt;/code&gt;，表示渐变将在超出定义范围时重复。&lt;/p&gt;
&lt;h3 id=&#34;sweepgradient&#34;&gt;SweepGradient&lt;/h3&gt;
&lt;p&gt;SweepGradient 是 Flutter 中实现扫描渐变效果的类，它可以用来创建在一个圆圈内均匀分布的颜色渐变效果。下面是 SweepGradient 的一些适用场景和利弊：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;需要实现在一个圆圈内均匀分布的颜色渐变效果，例如圆形背景、圆形边框等；
可以在任何需要使用颜色的地方使用，例如背景、边框、文本等。
利弊：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：可以创建在一个圆圈内均匀分布的颜色渐变效果，适用于多种需要扫描渐变的场景；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：不适合实现复杂的渐变效果，例如多个颜色之间的复杂渐变。对于这种情况，可以考虑使用 LinearGradient 或 RadialGradient 等其他类型的渐变。&lt;/p&gt;
&lt;p&gt;SweepGradient 属性列表以及说明:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;center&lt;/code&gt;：定义渐变的中心点位置，它是一个Alignment类型的对象。Alignment类型包含两个属性：x和y，分别表示水平和垂直方向上的偏移量。默认值是Alignment.center，表示渐变从中心点开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;startAngle&lt;/code&gt;：定义渐变的起始角度，它是一个浮点数，表示从中心点开始的起始角度。默认值是0.0，表示从正右方开始扫描。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;endAngle&lt;/code&gt;：定义渐变的结束角度，它是一个浮点数，表示从中心点开始的结束角度。默认值是2 * pi，表示扫描一周结束。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;colors&lt;/code&gt;：定义渐变的颜色数组。渐变将从数组的第一个颜色过渡到最后一个颜色。至少需要提供两个颜色。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stops&lt;/code&gt;：定义颜色数组中每个颜色的位置。每个位置的值必须在0.0到1.0之间。如果不提供stops属性，则渐变中每个颜色的位置将均匀分布。&lt;/p&gt;
&lt;p&gt;SweepGradient 的简单应用, 代码 以及 图例 如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  _sweepGradient(){
    return Center(
      child: Container(
          decoration: const BoxDecoration(
            gradient: SweepGradient(
              center: Alignment.center,
              startAngle: 0.0,
              endAngle: 2 * pi,
              colors: [Colors.red, Colors.yellow, Colors.green],
              stops: [0.0, 0.5, 1.0],
            ),
          ),
          child: Text(&amp;#34;SweepGradient 渐变&amp;#34;))
    );

  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/1678866078.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678866078.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中，我们创建了一个Container组件，并使用SweepGradient作为其背景。我们将渐变的中心点位置设置为Alignment.center，将起始角度设置为0.0，将结束角度设置为2 * pi，将颜色数组设置为[Colors.red, Colors.yellow, Colors.green]，并将停止位置数组设置为[0.0, 0.5, 1.0]。这意味着渐变将从红色开始，到黄色中间停止，然后到绿色结束。&lt;/p&gt;
&lt;h3 id=&#34;文本渐变&#34;&gt;文本渐变&lt;/h3&gt;
&lt;p&gt;这个是经常会在苹果官网看到, 绚丽多彩的渐变文本. 我们也可以用 flutter 轻松实现:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/1678866568.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;1678866568.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  _colorfulText() {
    return ShaderMask(
      shaderCallback: (bounds) {
        return const LinearGradient(
          colors: [Colors.blue, Colors.red],
          stops: [0.0, 1.0],
          begin: Alignment.centerLeft,
          end: Alignment.centerRight,
        ).createShader(bounds);
      },
      child: const Text(
        &amp;#34;this is way&amp;#34;,
        style: TextStyle(
          fontSize: 32.0,
          fontWeight: FontWeight.bold,
          color: Colors.white,
        ),
      ),
    );
  }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;代码地址&#34;&gt;代码地址&lt;/h3&gt;
&lt;p&gt;相关的代码实现你可以在这里找到: &lt;a class=&#34;link&#34; href=&#34;https://github.com/oooldCaption/flutter_blog/blob/main/lib/2023_03/gradient_view.dart&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;git_repo&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>数据结构(1)</title>
        <link>http://47.99.84.217/post/datastructureone/</link>
        <pubDate>Wed, 31 Jul 2019 15:03:49 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/datastructureone/</guid>
        <description>&lt;p&gt;在计算机科学中, 数据结构是计算机中存储, 组织数据的方式.为编程语言提供数据类型; 一个好的数据结构应该尽可能的使用较少的空间和时间资源, 支持各种程序的运行. 忘记在哪里看到的了, 一个程序就是&lt;strong&gt;数据结构+算法&lt;/strong&gt;; 常见的数据结构如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;链表&#34;&gt;链表&lt;/h3&gt;
&lt;p&gt;在物理内存上不一定是一段连续的存储空间, 增删的效率高于数组,因为他的特点是将&lt;strong&gt;数据与指标&lt;/strong&gt;进行配对并指导计算机根据指标在内存中进行上/下一条数据的数据操作;增删的效率要比数组高, 因为不需要修改内存结构. 但是在查询上与数组一样, 都是线性查找;&lt;/p&gt;
&lt;h4 id=&#34;单向链表&#34;&gt;单向链表&lt;/h4&gt;
&lt;p&gt;单向链表是链表中最简单的一种, 一个元素包含两个域,一个&lt;strong&gt;信息域&lt;/strong&gt;和&lt;strong&gt;指针域&lt;/strong&gt;;, 一个元素被分成两个部分, 信息域保存或者显示有关元素的信息, 另外一个部分存储链表中的下一个元素,形成链接, 最后一个元素的节点指针指向空.单向链表只能通过&lt;code&gt;next&lt;/code&gt;指针指向下一个节点; &lt;img src=&#34;http://img.52smile.vip/blog/2019-07-31-073150.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;单向链表&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;双向链表&#34;&gt;双向链表&lt;/h4&gt;
&lt;p&gt;双向链表比单向链表复杂一些, 比单向链表多了一个&lt;code&gt;prev&lt;/code&gt;指针指向上一个节点, 也就是说第二个元素可以知道我上一个节点和下一个节点在 位置信息; &lt;img src=&#34;http://img.52smile.vip/blog/2019-07-31-075456.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;双向链表&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;循环链表&#34;&gt;循环链表&lt;/h4&gt;
&lt;p&gt;循环链表中的首节点元素和末尾节点元素连接在一起. &lt;img src=&#34;http://img.52smile.vip/blog/2019-08-01-015725.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;循环链表&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;常见算法&#34;&gt;常见算法:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;输入一个单向链表, 输出反转链表&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//单链表的转置,循环方法
Node* reverseByLoop(Node *head)
{
    if(head == NULL  head-&amp;gt;next == NULL)
        return head;
    Node *pre = NULL;
    Node *next = NULL;
    while(head != NULL)
    {
        next = head-&amp;gt;next;
        head-&amp;gt;next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
//单链表的转置,递归方法
Node* reverseByRecursion(Node *head)
{
    //第一个条件是判断异常，第二个条件是结束判断
    if(head == NULL  head-&amp;gt;next == NULL)
        return head;
    Node *newHead = reverseByRecursion(head-&amp;gt;next);
    head-&amp;gt;next-&amp;gt;next = head;
    head-&amp;gt;next = NULL;
    return newHead;    //返回新链表的头指针
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>编程之美</title>
        <link>http://47.99.84.217/post/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/</link>
        <pubDate>Tue, 18 Sep 2018 18:05:08 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/</guid>
        <description>&lt;p&gt;好久没有更博客,天天忙也不知道都忙了什么; 之前说要连续写30天博客,连续推送30天代码的目标在某一天给断了. 结果也不了了之 昨天晚上临睡前看了一会 &lt;code&gt;O&#39; Reilly Media, Inc&lt;/code&gt; 出的 &lt;code&gt;Python学习手册&lt;/code&gt;, 在书中有一段讲Python和其他语言进行对比的段落,觉得说得很棒; 真是说到我心坎里了,因为最近正好做了一个项目,是二次开发; 嗯 ,说得好听的话叫做项目重构,说的不好听了叫项目重写; 当时拿到项目代码之后整个人是崩溃的,文件结构大概是这样子&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AAAClass.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AAAClass.m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BBBClass.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BBBClass.m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CCCClass.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CCCClass.m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;....
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;....
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;嗯,还没有文档&amp;hellip;..&lt;br&gt;
花了两天读了一下代码, 没有重构,没有继承,各种oop思想没有;&lt;/p&gt;
&lt;p&gt;生生把&lt;code&gt;Objective-C&lt;/code&gt;给写成了C语言;&lt;/p&gt;
&lt;p&gt;我想所有的程序员应该都知道, 代码是写给人看的, 不是写给机器和电脑看的..&lt;/p&gt;
&lt;p&gt;我觉得代码在设计和编写的时候更应该注重可读性,提高代码的可重用性,可维护性, 遵循这个原则,你的代码才不是写一次就丢掉的程序;&lt;/p&gt;
&lt;p&gt;当然,一个人做项目是挺爽,没有约束,天马行空,肆意汪洋,但是一周两周三周一个月两个月后呢,当你去维护项目的时候怎么办&amp;hellip;.&lt;/p&gt;
&lt;p&gt;对比Python和Perl这两种语言, 你可以用Python做到一切用Perl能到做到的事情, 但是做好之后, 你还可以阅读自己的程序代码;&lt;/p&gt;
&lt;p&gt;Python的美在于容易编写,容易阅读;更注重工程项目的可维护性;Perl就不一样,Perl很容易便携,但是程序员很难去阅读,你看代码很难猜到某一段代码的意图; 当然,这是因为两个语言的设计者背景不一样; 但是,这能体现人们选择使用Python的一些主要原因, 代码具有高度的统一性, 语法和工具集相当一致, 有一个很核心的概念, 简洁优美统一; Perl呢, 完成的方法不只有一种,所以,有了这种鼓励,每个人的代码风格都充满了独特性,充满技巧性;而这种独特的技巧常常是Perl使用者之间的骄傲来源;&lt;/p&gt;
&lt;p&gt;我想,任何做过实质性的代码维护工作的人,应该都可以正式, 自由的表达是一门很棒的艺术,但是对于一个工程来说就是很让人厌恶的一件事情了;&lt;/p&gt;
&lt;p&gt;在工程世界中,我们需要最小化功能集和可预测性;在工程世界中, 表达式自由度会造成维护的噩梦; 结果往往都是, 不行就推倒重来吧&amp;hellip;&lt;/p&gt;
&lt;p&gt;艺术和工程之间的关键差异在于个体的自由选择和一些独特的想法;但是一个优秀的程序员应该知道,代码应该是为下一个阅读它而进行维护或者重用的人写的.&lt;/p&gt;
&lt;p&gt;如果下一个人无法理解代码,那在实际开发场景中就毫无用处了; 所以呀,好好写代码; 做好文档建设工作,认真写注释;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CentOS 下安装 Redis</title>
        <link>http://47.99.84.217/post/centos-xia-an-zhuang-redis/</link>
        <pubDate>Sat, 15 Sep 2018 14:51:47 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/centos-xia-an-zhuang-redis/</guid>
        <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;安装Redis需要知道自己需要哪个版本，有针对性的安装，比如如果需要redis GEO这个地理集合的特性，那么redis版本就不能低于3.2版本，由于这个特性是3.2版本才有的。另外需要注意的是，Redis约定次版本号（即第一个小数点后的数字）为偶数的版本是稳定版（如2.8版、3.0版），奇数版本是非稳定版（如2.7版、2.9版），生产环境下一般需要使用稳定版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;下载安装包&#34;&gt;下载安装包&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget http://download.redis.io/releases/redis-4.0.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;解压并安装&#34;&gt;解压并安装&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tar xzf redis-4.0.2.tar.gz
cd redis-4.0.2
make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Redis没有其他外部依赖，安装过程很简单。编译后在Redis源代码目录的src文件夹中可以找到若干个可执行程序，安装完后，在/usr/local/bin目录中可以找到刚刚安装的redis可执行文件。 如下:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/2018-09-15-134934.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;redis 安装目录&#34;
	
	
&gt; 那你也可以通过命令 &lt;code&gt;redis -server&lt;/code&gt; 命令来执行启动 redis; 启动后界面如下: &lt;img src=&#34;https://img.52smile.vip/2018-09-15-135404.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;redis 启动界面&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置初始化脚本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先将初始化脚本复制到/etc/init.d 目录中，文件名为 redis_端口号，其中端口号表示要让Redis监听的端口号，客户端通过该端口连接Redis。然后修改脚本第6行的REDISPORT变量的值为同样的端口号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立需要使用的文件夹&lt;/p&gt;
&lt;p&gt;目录名&lt;/p&gt;
&lt;p&gt;配置项&lt;/p&gt;
&lt;p&gt;/etc/redis&lt;/p&gt;
&lt;p&gt;存放redis 的配置文件&lt;/p&gt;
&lt;p&gt;/etc/redis/端口号&lt;/p&gt;
&lt;p&gt;存放 redis持久化文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tip: vim 模式下使用 &lt;code&gt;?&lt;/code&gt; 命令进行搜索, &lt;code&gt;n&lt;/code&gt;跳转到下一个搜索结果;&lt;code&gt;N&lt;/code&gt;跳转上一个搜索结果 3.修改配置文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先将配置文件模板（redis-4.0.2/redis.conf）复制到/etc/redis 目录中，以端口号命名（eg: “6379.conf”），然后按照下表对其中的部分参数进行编辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;params&lt;/p&gt;
&lt;p&gt;value&lt;/p&gt;
&lt;p&gt;tip&lt;/p&gt;
&lt;p&gt;daemonize&lt;/p&gt;
&lt;p&gt;yes&lt;/p&gt;
&lt;p&gt;redis 以守护进程模式运行&lt;/p&gt;
&lt;p&gt;pidfile&lt;/p&gt;
&lt;p&gt;/var/run/redis_端口号.pid&lt;/p&gt;
&lt;p&gt;设置Redis的PID文件位置&lt;/p&gt;
&lt;p&gt;port&lt;/p&gt;
&lt;p&gt;端口号&lt;/p&gt;
&lt;p&gt;被监听的端口号 dir /var/redis/端口号 redis持久化文件&lt;/p&gt;
&lt;p&gt;配置完成以后你可以通过命令行启动 redis&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/etc/init.d/redis_6379 start
/etc/init.d/redis_6379 stop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别忘记配置自动启动~ 修改配置文件: &lt;code&gt;etc/init.d/redis_6379.conf;&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim etc/init.d/redis_6379.conf
在头部的第五行添加
# chkconfig: 2345 90 10
# description: Redis is a persistent key-value database
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;正确的停止-redis&#34;&gt;正确的停止 redis&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑到 Redis 有可能正在将内存中的数据同步到硬盘中，强行终止 Redis 进程可能会导致数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;redis-cli SHUTDOWN&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当Redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。Redis可以妥善处理 SIGTERM信号，所以使用 kill Redis 进程的 PID也可以正常结束Redis，效果与发送SHUTDOWN命令一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ioser.net/archives/27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考基友Martin的文章&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>js数组去重</title>
        <link>http://47.99.84.217/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
        <pubDate>Wed, 12 Sep 2018 15:25:33 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
        <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近参与公司 ERP 项目, 负责了一下前端页面开发; 之前接触 js 比较浅, 在做项目中遇到了一些问题, 比如数组去重, 对象数组去重等问题;&lt;/p&gt;
&lt;h3 id=&#34;使用-arrayform-set集合&#34;&gt;使用 Array.form() set集合&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let arr = [1,1,2,3,4];
let result= Array.from(new Set(arr));
console.log(result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;遍历利用-indexof-判断&#34;&gt;遍历,利用 indexOf 判断&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let arr = [1,1,2,3,4];
var temp= [];
for (i in  arr){
    if(temp..indexOf(arr[i]) == -1){
        temp.push(arr[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;遍历-利用对象的-key-判断数据值&#34;&gt;遍历 利用对象的 key, 判断数据值&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var arr = [
    {id: &amp;#39;121&amp;#39;, count: 20},
    {id: &amp;#39;122&amp;#39;, count: 20},
    {id: &amp;#39;123&amp;#39;, count: 20},
    {id: &amp;#39;121&amp;#39;, count: 10},
    {id: &amp;#39;122&amp;#39;, count: 11}
];
let tempDict = {};
let newArr = [];
   for(let i=0;i&amp;lt;arr.length;i++) {
     if(!tempDict[arr[i].id]) {
       tempDict[arr[i].id] = true;
       newArr.push(arr[i]);
     }
   }
console.log(newArr);
Array(3)
{id: &amp;#34;121&amp;#34;, count: 20}
{id: &amp;#34;122&amp;#34;, count: 20}
{id: &amp;#34;123&amp;#34;, count: 20}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;foreach&#34;&gt;forEach&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let arr1 = [{skuid:1111,count:222},{skuid:2222,count:3},{skuid:1111,count:222},{skuid:2222,count:3}];
let temp= [];
arr1.forEach(item =&amp;gt; {
                    item = Object.assign(item);
                    let sku = this.alertInfoArr.find(sku=&amp;gt;sku.skuId===item.skuId);
                    if(!sku){
                        temp.push(item);
                    }
                });
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>使用Hexo&#43;Coding搭建个人博客</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8hexocoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Tue, 17 Apr 2018 15:10:01 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8hexocoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;p&gt;前言 之前博客挂在 github pages 上,回到工作地之后发现访问不了了.一琢磨就买个个主机使用 wordpress搭建了个个人博客,当使用 wordpress 实在是不能提起我的写作欲望,又麻溜的切换到了 hexo.在网上看到了coding 也提供了类似 github pages 的服务 coding-pages,瞬间觉得太好了.于是我又开始了 hexo 之旅;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;正文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境：　mac　os ＋　hexo3.0　＋ iTerm　＋ Mou　＋ next + homebrew １．　安装非常简单，只需要几分钟即可搞定；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;２．　查看你的电脑中有没有安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js&lt;/li&gt;
&lt;li&gt;Git.&lt;/li&gt;
&lt;li&gt;如果您的电脑没有安装上诉的程序,可以点击访问安装;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了,如果这些步骤都完成,您就可以安装 hexo 了;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install -g hexo-cli&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;建站 执行下面的命令,Hexo 会在文件夹中新建需要的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo init folder hexo init&lt;/code&gt;
~Document/Hexo e.g. cd folder npm install&lt;/p&gt;
&lt;p&gt;完成这一步之后,您就可以在您的 hexo 文件夹下执行 &lt;code&gt;hexo g hexo s&lt;/code&gt; 在浏览器中访问 &lt;code&gt;http://localhost:4000&lt;/code&gt;,这是您就能看到 Hexo 的页面了,是不是很帅!&lt;/p&gt;
&lt;p&gt;轻轻松松就看到了效果,有没有觉得很有成就感;&lt;/p&gt;
&lt;p&gt;当然这个博客是存在于您的本地;&lt;/p&gt;
&lt;p&gt;先别着急,咱们看一下本地怎么配置,怎么配置主题;&lt;/p&gt;
&lt;p&gt;在 Hexo 文件夹下有一个&lt;code&gt;config.yml&lt;/code&gt;,就叫他 站点配置文件吧;&lt;/p&gt;
&lt;p&gt;文件不大,加上注释空行也就八十多行;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 
 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思 title: 两好三坏 #博客名 subtitle: 爱情,两好三坏 #副标题 description: 长恨人心不如水,等闲平地起波澜 #用于搜索，没有直观表现 author: 两好三坏 #作者 language: zh-CN #语言 timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值 # URL 暂不配置，使用默认值 ## If your site is put in a subdirectory, set url as &amp;#39;http://yoursite.com/child&amp;#39; and root as &amp;#39;/child/&amp;#39; url: http://opiece.me #域名 root: / permalink: :year/:month/:day/:title/ permalink\_defaults: # Directory 暂不配置，使用默认值 source\_dir: source public\_dir: public tag\_dir: tags archive\_dir: archives category\_dir: categories code\_dir: downloads/code i18n\_dir: :lang skip\_render: # Writing 文章布局等，使用默认值 new\_post\_name: :title.md # File name of new posts default\_layout: post titlecase: false # Transform title into titlecase external\_link: true # Open external links in new tab filename\_case: 0 render\_drafts: false post\_asset\_folder: false relative\_link: false future: true highlight: enable: true line\_number: true tab\_replace: # Category Tag 暂不配置，使用默认值 default\_category: uncategorized category\_map: tag\_map: # Date / Time format 时间格式，使用默认值 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date\_format: YYYY-MM-DD time\_format: HH:mm:ss # Pagination ## Set per\_page to 0 to disable pagination per\_page: 10 #每页显示的文章数，0表示不分页 pagination\_dir: page # Extensions 插件配置，暂时不配置 ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: hexo-theme-next #使用的主题，即：themes文件夹下的主题文件夹名 feed: #之后配置rss会用，使用如下配置即可 type: path: limit: # Deployment 用于部署到github，之前已经配置过 ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: https://git.coding.net/usename/usename.git #coding仓库地址 branch: coding-pages 再次运行 hexo,看看 hexo 比第一次打开之后顺眼多了,至少变成汉字了吧~哈哈哈哈哈哈 切换主题,主题配置文件 在iTerm进入到 Hexo 目录下,然后执行 git 下载 next 主题 git clone https://github.com/iissnan/hexo-theme-next.git 下载完成后会在 hexo 下的 theme 文件下,文件名夹名为 hexo-theme-next,在站点配置文件中将主题设置为 hexo-theme-next;再次运行 hexo s 查看效果,是不是跟开心啦~~~ 在hexo-theme-next中有\_config.yml,这是是主题的配置文件 你可以在Next 帮助文档查看如何个性化定制; 写作]

*   你可以使用下列命令创建一个新的文章:
*   hexo new \[layout\] &amp;lt;title&amp;gt; ,layout 是布局,title 是文章标题; 写作是使用 markdown语法,你可以在MarkDown 语法入门查看; 如果你需要标签功能和分类功能,在终端进入到您的hexo文件夹下 执行:
*   hexo new page &amp;#34;tags&amp;#34; 创建标签页面,在hexo 文件夹下的 \\source\\tags\\index.md 中添加一个 type: “tags”
* [[  hexo new page categories 创建分类页面,在hexo 文件夹下的 \\source\\categories\\index.md 中添加一个 type: “categories” 然后你也可以在hexo 文件夹下的 \\scaffolds\\post.md 中添加一个上 tags: categories: ,这个 post 是你每次书写的时候的一个模板;添加后每次创建行的文章就不用去在添加 tags 和 categories 了;]]

部署 写作完成之后可以使用命令 hexo g生成静态页面.在后运行 hexo s查看效果; hexo d是部署到 coding 或者 github 上面,在站点配置文件中 deploy: type: git repo: https://git.coding.net/usename/usename.git #coding仓库地址 branch: coding-pages

*   你可以先到 coding 上面去申请一个帐号,然后行创建一个与你 coding 用户名相同的项目;
*   打开你刚才创建的项目,有一栏叫做 Page 服务,打开,然后选择部署;
*   hexo d是提交到你这个 repo的仓库,如果你没有配置 ssh,那么可能就提示您输入您的从coding 上的用户名和密码来验证;
*   如果宁蒗的输入,可以配置 ssh 公钥来进行配置点击查看配置 ssh 当您完成写作之后执行 hexo g &amp;amp; hexo s,过上一会就可以访问您的文章了;

绑定域名 如果您有自己的域名,你可以在在 dns 解析添加解析到 pages.coding.me;这样别人就可以通过域名访问您的博客了;
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>css盒子模型 - - 前端开发</title>
        <link>http://47.99.84.217/post/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Tue, 17 Apr 2018 15:02:57 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;p&gt;css 框模型(BoxModel) 定义了元素框处理元素内容, 内/外边距,边框, 外边框的方式; CSS 框模型概述: 元素框的最内部分是实际的内容, 直接包围内容的是内边距(*padding); 内边距呈现的是元素的背景, 内边距的边缘是边框(border, 可设置bordercolor borderwidth); 边框以为是外边框 , 外边框的默认背景色是透明的, 因此不会遮挡其后的任何元素;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;内边距, 边框,外边距都是可选的, 默认值是0. 但是,许多元素将由用户代理样式表设置外边距和内边距. 可以通过将元素的margin 和padding 设置为0 来覆盖这些浏览器样式. 这样可以分别进行, 也可以使用通用选择器对所有元素进行设置:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; * {
    margin : 0;
    padding: 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 css 中, width 和height指的是内容区域的宽度和高度;增减内外边距和边框并不会影响内容区域的尺寸,但是影响元素框的总尺寸 假设框的每一个边上都有10 个像素的外边距和5个像素的内边距. 如果希望这个元素框达到100个像素, 那就需要将内容的宽度设置为 70 像素,:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#box {
width: 70px;
margin: 10px;
padding: 5px;
}
/*
tip:
 内外边距,边框都可以应用于一个元素的所有便, 也可以用于单独的边
 eg : border-left-width: 10px ;  ---&amp;gt; 单独给左侧边框线设置线宽为10px
 外边距可以使负值, 而且在很多情况下都要使用复制的外边距;
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS内边距: 元素的内边距在的边框和内容之间, 控制该区域最简单的属性是padding属性, css 的padding属性定义元素边框与元素内容之间的空白区域; css padding 属性 CSS padding 属性定义元素的内边距。padding 属性接受长度值或百分比值，但不允许使用负值。 例如，如果您希望所有 h1 元素的各边都有 10 像素的内边距，只需要这样： l&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;h1 {padding: 10px;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;您还可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;h1 {padding: 10px 0.25em 2ex 20%;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;单边内边距的属性值:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;padding-top 上内边距&lt;/li&gt;
&lt;li&gt;padding-bottom 下内边距&lt;/li&gt;
&lt;li&gt;padding-left 左内边距&lt;/li&gt;
&lt;li&gt;padding-right 右内边距 h1 { padding-top: 10px; padding-right: 0.25em; padding-bottom: 2ex; padding-left: 20%; }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS 边框 在 HTML 中，我们使用表格来创建文本周围的边框，但是通过使用 CSS 边框属性，我们可以创建出效果出色的边框，并且可以应用于任何元素。 元素外边距内就是元素的的边框 (border)。元素的边框就是围绕元素内容和内边据的一条或多条线。 每个边框有 3 个方面：宽度、样式，以及颜色。 边框与背景 CSS 规范指出，边框绘制在“元素的背景之上”。这很重要，因为有些边框是“间断的”（例如，点线边框或虚线框），元素的背景应当出现在边框的可见部分之间。 CSS2 指出背景只延伸到内边距，而不是边框。后来 CSS2.1 进行了更正：元素的背景是内容、内边距和边框区的背景。大多数浏览器都遵循 CSS2.1 定义，不过一些较老的浏览器可能会有不同的表现。 边框的样式 样式是边框最重要的一个方面，这不是因为样式控制着边框的显示（当然，样式确实控制着边框的显示），而是因为如果没有样式，将根本没有边框。 CSS 的 border-style 属性定义了 10 个不同的非 inherit 样式，包括 none。 例如，您可以为把一幅图片的边框定义为 outset，使之看上去像是“凸起按钮”：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a:link img {border-style: outset;}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义多种样式: p.aside {border-style: solid dotted dashed double;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义单边样式: border-top-style border-right-style border-bottom-style border-left-style&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边框的宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过border-width 置顶边框宽度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em；或者使用 3 个关键字之一，它们分别是 thin 、medium（默认值） 和 thick。 注释：CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px，而另一个用户代理则分别设置为 3px、2px 和 1px。 所以，我们可以这样设置边框的宽度：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {border-style: solid; border-width: 5px;}
or
p {border-style: solid; border-width: thick;}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义单边的线宽 p {border-style: solid; border-width: 15px 5px 15px 5px;} border-right-width border-bottom-width border-left-width border-top-width&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有边框&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果希望显示某种边框, 就需要设置边框样式 , 默认情况下 border-style 默认 是none ; 如果我们设置style 为none , 然后设置边框的宽度, 边框的样式是不存在的, 而且 边框的宽度自动设置成0 , 所以,我们需要设置边框的时候, 一定要使用 border-style 进行设置一下边框线的style; 边框的颜色 border-corlor 设置边框颜色非常简单。CSS 使用一个简单的 border-color 属性，它一次可以接受最多 4 个颜色值。 可以使用任何类型的颜色值，例如可以是命名颜色，也可以是十六进制和 RGB 值：\&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {
  border-style: solid;
  border-color: blue rgb(25%,35%,45%) #909090 red;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果颜色值小于 4 个，值复制就会起作用。例如下面的规则声明了段落的上下边框是蓝色，左右边框是红色：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {
  border-style: solid;
  border-color: blue red;
  }
/*
注释：默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色
相同。另一方面，如果元素没有任何文本，假设它是一个表格，其中只包含图像，那么该表的边
框颜色就是其父元素的文本颜色（因为 color 可以继承）。这个父元素很可能是 body、div
或另一个 table。
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义单边颜色&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;border-top-color
border-right-color
border-bottom-color
border-left-color
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;css margin 属性 外边距 绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。 设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。 设置外边距最简单的方法就是使用margin属性 , margin 接受任意长度的单位, 像素, 毫米, 英寸,em 也可以设置成auto, 值赋值 我们有时候会输入一些重复的数字,来设置margin 或者 border 或者padding eg :&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {margin: 0.5em 1em 0.5em 1em };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过值复制, 你可以不用重复输入数字&amp;quot;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p{margin: 0.5em 1em};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两个数值可以取代前面的四个数值, CSS定义了一些规则, 允许外部安居指定少于4个值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺少左外边距, 默认使用右外边距&lt;/li&gt;
&lt;li&gt;缺少下外边距,默认使用上外边距&lt;/li&gt;
&lt;li&gt;缺少右外边距,使用上外边距;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;h1 {margin: 0.25em 1em 0.5em;}  /* 等价于 0.25em 1em 0.5em 1em */
h2 {margin: 0.5em 1em;}     /* 等价于 0.5em 1em 0.5em 1em */
p {margin: 1px;}            /* 等价于 1px 1px 1px 1px */
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Ajax 初识</title>
        <link>http://47.99.84.217/post/ajax-%E5%88%9D%E8%AF%86/</link>
        <pubDate>Tue, 17 Apr 2018 15:01:46 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ajax-%E5%88%9D%E8%AF%86/</guid>
        <description>&lt;p&gt;Ajax AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。并不是一种开发语言,是聪明的程序员对 javascript 的创造性用法; Ajax 提供与服务器异步通信的能力,最简单的应用就是无需刷新整个页面而更新网页某一个部分的数据,更快,更高,更强~~~ 使用这个技术还是很简单的.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;1.创建 XMLHttpRequest 对象&lt;/p&gt;
&lt;p&gt;//创建对象的语法:&lt;/p&gt;
&lt;p&gt;variable = new XMLHttpRequest()lt;br/gt;&lt;/p&gt;
&lt;p&gt;//如果需要向下兼容 ie5,5,我们需要 ActiveX 对象lt;br/gt;&lt;/p&gt;
&lt;p&gt;variable = new ActiveXobject(quot;Microsoft.XMLHTTPquot;)lt;br/gt;&lt;/p&gt;
&lt;p&gt;var xmlhttp;&lt;/p&gt;
&lt;p&gt;if (window.XMLHttpRequest){&lt;/p&gt;
&lt;p&gt;xmlhttp=new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;}else{&lt;/p&gt;
&lt;p&gt;xmlhttp=new ActiveXObject(quot;Microsoft.XMLHTTPquot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这样我们就创建一个 XMLHttpRequest 的对象,我们就可以使用这个对象进行请求数据; ２.向服务器发送请求 如果我们向服务器发送请求，就需要用到xmlhttp 的 open()和send() 方法&lt;/p&gt;
&lt;p&gt;open()有三个参数,第一个参数是请求类型 put,get,post;&lt;/p&gt;
&lt;p&gt;第二个参数是 url,即文件在服务器上的地址&lt;/p&gt;
&lt;p&gt;第三个参数是同步 or 异步&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;open(method,url,asyns)&lt;/p&gt;
&lt;p&gt;!&amp;ndash;&lt;/p&gt;
&lt;p&gt;发送请求,string 用于 post 请求&lt;/p&gt;
&lt;p&gt;但我们需要提交一些表单之类的数据的时候,需要用到 post 提交&lt;/p&gt;
&lt;p&gt;需要在 setRequestHeader()中添加请求有信息,在后再 send()中添加数据&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;send(string)&lt;/p&gt;
&lt;p&gt;xmlhttp.onreadystatechange=function()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;if (xmlhttp.readyStatelt;markgt;4 amp;amp; xmlhttp.statuslt;/markgt;200)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;// responseText amp; responseXML;一个是字符串形式的响应数据,一个是 xml 形式的响应数据XML 可以使用 name.getElementsByName(quot;节点名称quot;)进行读取&lt;/p&gt;
&lt;p&gt;document.getElementById(quot;myDivquot;).innerHTML=xmlhttp.responseText;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;xmlhttp.open(quot;GETquot;,url,true);&lt;/p&gt;
&lt;p&gt;xmlhttp.send();&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;上面的 readyState表示存有 XMLHttpRequest 的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0:请求未初始化&lt;/li&gt;
&lt;li&gt;1:服务器连接已建立&lt;/li&gt;
&lt;li&gt;2:请求已经接受&lt;/li&gt;
&lt;li&gt;3:请求处理中&lt;/li&gt;
&lt;li&gt;4:请求已完成,响应就绪; 上面的 status&lt;/li&gt;
&lt;li&gt;200:”OK&lt;/li&gt;
&lt;li&gt;404:未找到页面&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>使用thinkphp分页&amp;上传图片</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8thinkphp%E5%88%86%E9%A1%B5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</link>
        <pubDate>Tue, 17 Apr 2018 14:49:42 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8thinkphp%E5%88%86%E9%A1%B5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</guid>
        <description>&lt;p&gt;使用 thinkPHP 实现分页: 新建控制器LoginController.class.php 在 LoginController 中创建 index 方法:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Page 类 和 limit方法实现&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$data  = M(&amp;#39;userinfo&amp;#39;);
$map[&amp;#39;user_id&amp;#39;] = array(&amp;#39;gt&amp;#39;,0);
$count = $data-&amp;gt;where()-&amp;gt;count(); // 满足条件的记录数
//Page 的构造方法,第一个参数为总记录数,第二个是每页显示的数量
$page = new Page($count,5);
$show = $page-&amp;gt;show();
$list = $User-&amp;gt;where($map)-&amp;gt;order(&amp;#39;create_time&amp;#39;)-&amp;gt;limit($Page-&amp;gt;firstRow.&amp;#39;,&amp;#39;.$Page-&amp;gt;listRows)-&amp;gt;select();
$this-&amp;gt;assign(&amp;#39;list&amp;#39;,$list);// 赋值数据集
$this-&amp;gt;assign(&amp;#39;page&amp;#39;,$show);// 赋值分页输出
$this-&amp;gt;display();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在对应的试图模板中编写如下代码:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;table cellpadding=3 cellspacing=5&amp;gt;
    &amp;lt;volist name=&amp;#34;list&amp;#34; id=&amp;#34;vo&amp;#34;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td &amp;gt;[ {$vo.user_id} ] {$vo.user_id} &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/volist&amp;gt;
    &amp;lt;tr&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;div class=&amp;#34;resultpage&amp;#34; style=&amp;#34;width: 500px&amp;#34;&amp;gt;{$page}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样在对应的视图就会显示相应的页码和数据信息;不过有点难看,不过别担心,稍后咱们在重新设置; 接下来咱们看第二种实现方式: 分页类和 page 方法的实现 将 index 方法中的代码替换成如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$data  = M(&amp;#39;userinfo&amp;#39;);
$map[&amp;#39;user_id&amp;#39;] = array(&amp;#39;gt&amp;#39;,0);
$list = $data-&amp;gt;where($map)-&amp;gt;order(&amp;#39;user_id)-&amp;gt;page($_GET[&amp;#39;p&amp;#39;].&amp;#39;,5&amp;#39;)-&amp;gt;select();
$this-&amp;gt;assgin(&amp;#39;list&amp;#39;,$list);
//引入分页模块
$count = $data-&amp;gt;where($map)-&amp;gt;count();
$page = new Page($count, &amp;#39;5&amp;#39;);
$show = $page-&amp;gt;show();
$this -&amp;gt; assgin(&amp;#39;page&amp;#39;,$show);
$this-&amp;gt;display();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改分页显示效果 thinkphp 中的分页类 Page 提供了一个方法 setConfig 来修改分页栏的显示效果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;header：头部描述信息，默认值 “条记录”&lt;/li&gt;
&lt;li&gt;prev：上一页描述信息，默认值是“上一页”&lt;/li&gt;
&lt;li&gt;next：下一页描述信息，默认值是“下一页”&lt;/li&gt;
&lt;li&gt;first：第一页描述信息，默认值是“第一页”&lt;/li&gt;
&lt;li&gt;last：最后一页描述信息，默认值是“最后一页”&lt;/li&gt;
&lt;li&gt;theme ：分页主题描述信息， `` $page-&amp;gt;lastSuffix = false; $page-&amp;gt;setConfig(&amp;lsquo;header&amp;rsquo;,&amp;lsquo;共**%TOTAL_ROW%**条记录&amp;rsquo;); $page-&amp;gt;setConfig(&amp;lsquo;prev&amp;rsquo;,&amp;rsquo;&amp;lt;&amp;rsquo;); $page-&amp;gt;setConfig(&amp;rsquo;next&amp;rsquo;,&amp;rsquo;&amp;gt;&amp;rsquo;); $page-&amp;gt;setConfig(&amp;lsquo;first&amp;rsquo;,&amp;lsquo;首页&amp;rsquo;); $page-&amp;gt;setConfig(&amp;rsquo;last&amp;rsquo;,&amp;lsquo;尾页&amp;rsquo;); $page-&amp;gt;setConfig(&amp;rsquo;theme&amp;rsquo;, &amp;lsquo;%FIRST%%UP_PAGE%%LINK_PAGE%%DOWN_PAGE%%END%%HEADER%&amp;rsquo;); 我们还可以使用 &lt;code&gt;css&lt;/code&gt; 属性对分页栏的显示效果进行修改: 上面列表中的 &lt;code&gt;header&lt;/code&gt; &lt;code&gt;prev&lt;/code&gt; &lt;code&gt;next&lt;/code&gt; 等等再视图模板中都是以元素的 &lt;code&gt;class&lt;/code&gt; 值体现的,所以我们可以通过修改 class 的样式表定制显示效果,达到我们想要的效果:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.resultpage{&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;background: black;
color: honeydew;
margin-right: 5px;
margin-left: 5px;
padding-left: 5px;
padding-right: 5px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.num {&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;color: honeydew;
padding-left: 5px;
padding-right: 5px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;} .current{color: red;} .prev{color: honeydew;} .next{color: honeydew;} .last{color: honeydew;} .first{color: honeydew;} a{text-decoration: none}&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用cookie实现自动登录</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</link>
        <pubDate>Tue, 17 Apr 2018 14:48:57 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</guid>
        <description>&lt;p&gt;关于 cookie 在日常开发中我们会遇到这样的需求场景: 用户在首次登录使用后,离开了这个网站(没有点击注销登录), 再次回到这个站点的时候,不需要重新登录,仍是自己上次登陆的账号信息; 我们可以使用 cookie 中存储用户的信息,并且判断是否需要加载用户信息并重新登录; php 使用 setCookie 函数来设置 Cookie 信息,但是有一点值得注意,Cookie是HTTP协议头的一部分，用于浏览器和服务器之间传递信息，&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;所以必须在任何属于HTML文件本身的内容输出之前调用Cookie函数。 也就是说,在 setcookie 之前不能进行输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo &amp;#39;我要设置 cookie了&amp;#39;;
setCookie(&amp;#39;value&amp;#39;,&amp;#39;key&amp;#39;,time());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种会造成设置 cookie 无效; 使用 cookie 实现自动登录 登陆成功后存储用户的信息: 在登录成功后通过 setCookie 设置用户信息,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; public function login()
 {
    if (!empty($_POST)){
        $userpsw = array(
            &amp;#39;username&amp;#39;=&amp;gt;$_POST[&amp;#39;username&amp;#39;],
            &amp;#39;password&amp;#39;=&amp;gt;$_POST[&amp;#39;password&amp;#39;],
         );
        $info = D(&amp;#39;userinfo&amp;#39;)-&amp;gt;where($userpsw)-&amp;gt;find();
        if ($info){
            $re = setcookie(&amp;#39;userinfo&amp;#39;,md5($_POST[&amp;#39;username&amp;#39;]),time()+3600,&amp;#39;/&amp;#39;);
            $re = setcookie(&amp;#39;password&amp;#39;,MD5($_POST[&amp;#39;password&amp;#39;]),time()+3600,&amp;#39;/&amp;#39;);
            dump($re);
            echo &amp;#39;登陆成功&amp;#39;;
            $this-&amp;gt;display();
            }else{
                echo &amp;#39;登录失败&amp;#39;;
            }
        }
    }else{
        $this-&amp;gt;display();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 cookie 我们还可以保存用户的偏好设置信息,在用户下次访问的时候推送用户可能会感兴趣的信息; 判断是否需要自动登录 可以再模板文件中通过 js 获取 cookie 进行判断是否需要自动加载用户信息,也可以在 php 的控制其中进行判断,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt;
$(document).ready(function () {
var name = getCookie(&amp;#39;nickname&amp;#39;);
var password = getCookie(&amp;#39;psw&amp;#39;);
if(name &amp;amp;&amp;amp; password){
    //自动登录
}else{
    //手动登录
}
   console.log(getCookie(&amp;#39;nickname&amp;#39;));
});
function getCookie(c_name)
{
    if (document.cookie.length&amp;gt;0)
    {
        c_start=document.cookie.indexOf(c_name + &amp;#34;=&amp;#34;)
        if (c_start!=-1)
        {
            c_start=c_start + c_name.length+1
            c_end=document.cookie.indexOf(&amp;#34;;&amp;#34;,c_start)
            if (c_end==-1) c_end=document.cookie.length
            return unescape(document.cookie.substring(c_start,c_end))
        }
    }
    return &amp;#34;&amp;#34;
}
&amp;lt;/script&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
    </channel>
</rss>
