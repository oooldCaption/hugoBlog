<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>软件开发 on 煎人寿</title>
        <link>http://47.99.84.217/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
        <description>Recent content in 软件开发 on 煎人寿</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sun, 20 Nov 2022 17:52:38 +0800</lastBuildDate><atom:link href="http://47.99.84.217/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Flutter 渐变</title>
        <link>http://47.99.84.217/post/flutter-%E6%B8%90%E5%8F%98/</link>
        <pubDate>Sun, 20 Nov 2022 17:52:38 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/flutter-%E6%B8%90%E5%8F%98/</guid>
        <description>&lt;p&gt;太久没写技术博客啦.    最近一直在用&lt;code&gt;fluter&lt;/code&gt;做app,  前几天有个功能需要用渐变色来做一个文本.&lt;/p&gt;
&lt;p&gt;我回想起几年前被我们UI设计师支配的恐惧, 那个UI特别喜欢用渐变色跟圆角, 以至于天天跟CALayer之类的打交道.&lt;/p&gt;
&lt;p&gt;如果想要在flutter上实现渐变色就太简单了, 在&lt;code&gt;Container&lt;/code&gt;容器中有一个修饰器&lt;code&gt;decoration&lt;/code&gt;中 有一个 &lt;code&gt;gradient&lt;/code&gt;属性,  你只要给这个属性设置值, 就可以对容器设置渐变色了.
代码如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>数据结构(1)</title>
        <link>http://47.99.84.217/post/datastructureone/</link>
        <pubDate>Wed, 31 Jul 2019 15:03:49 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/datastructureone/</guid>
        <description>&lt;p&gt;在计算机科学中, 数据结构是计算机中存储, 组织数据的方式.为编程语言提供数据类型; 一个好的数据结构应该尽可能的使用较少的空间和时间资源, 支持各种程序的运行. 忘记在哪里看到的了, 一个程序就是&lt;strong&gt;数据结构+算法&lt;/strong&gt;; 常见的数据结构如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;li&gt;树&lt;/li&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;链表&#34;&gt;链表&lt;/h3&gt;
&lt;p&gt;在物理内存上不一定是一段连续的存储空间, 增删的效率高于数组,因为他的特点是将&lt;strong&gt;数据与指标&lt;/strong&gt;进行配对并指导计算机根据指标在内存中进行上/下一条数据的数据操作;增删的效率要比数组高, 因为不需要修改内存结构. 但是在查询上与数组一样, 都是线性查找;&lt;/p&gt;
&lt;h4 id=&#34;单向链表&#34;&gt;单向链表&lt;/h4&gt;
&lt;p&gt;单向链表是链表中最简单的一种, 一个元素包含两个域,一个&lt;strong&gt;信息域&lt;/strong&gt;和&lt;strong&gt;指针域&lt;/strong&gt;;, 一个元素被分成两个部分, 信息域保存或者显示有关元素的信息, 另外一个部分存储链表中的下一个元素,形成链接, 最后一个元素的节点指针指向空.单向链表只能通过&lt;code&gt;next&lt;/code&gt;指针指向下一个节点; &lt;img src=&#34;http://img.52smile.vip/blog/2019-07-31-073150.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;单向链表&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;双向链表&#34;&gt;双向链表&lt;/h4&gt;
&lt;p&gt;双向链表比单向链表复杂一些, 比单向链表多了一个&lt;code&gt;prev&lt;/code&gt;指针指向上一个节点, 也就是说第二个元素可以知道我上一个节点和下一个节点在 位置信息; &lt;img src=&#34;http://img.52smile.vip/blog/2019-07-31-075456.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;双向链表&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;循环链表&#34;&gt;循环链表&lt;/h4&gt;
&lt;p&gt;循环链表中的首节点元素和末尾节点元素连接在一起. &lt;img src=&#34;http://img.52smile.vip/blog/2019-08-01-015725.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;循环链表&#34;
	
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;常见算法&#34;&gt;常见算法:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;输入一个单向链表, 输出反转链表&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//单链表的转置,循环方法
Node* reverseByLoop(Node *head)
{
    if(head == NULL  head-&amp;gt;next == NULL)
        return head;
    Node *pre = NULL;
    Node *next = NULL;
    while(head != NULL)
    {
        next = head-&amp;gt;next;
        head-&amp;gt;next = pre;
        pre = head;
        head = next;
    }
    return pre;
}
//单链表的转置,递归方法
Node* reverseByRecursion(Node *head)
{
    //第一个条件是判断异常，第二个条件是结束判断
    if(head == NULL  head-&amp;gt;next == NULL)
        return head;
    Node *newHead = reverseByRecursion(head-&amp;gt;next);
    head-&amp;gt;next-&amp;gt;next = head;
    head-&amp;gt;next = NULL;
    return newHead;    //返回新链表的头指针
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>编程之美</title>
        <link>http://47.99.84.217/post/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/</link>
        <pubDate>Tue, 18 Sep 2018 18:05:08 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/</guid>
        <description>&lt;p&gt;好久没有更博客,天天忙也不知道都忙了什么; 之前说要连续写30天博客,连续推送30天代码的目标在某一天给断了. 结果也不了了之 昨天晚上临睡前看了一会 &lt;code&gt;O&#39; Reilly Media, Inc&lt;/code&gt; 出的 &lt;code&gt;Python学习手册&lt;/code&gt;, 在书中有一段讲Python和其他语言进行对比的段落,觉得说得很棒; 真是说到我心坎里了,因为最近正好做了一个项目,是二次开发; 嗯 ,说得好听的话叫做项目重构,说的不好听了叫项目重写; 当时拿到项目代码之后整个人是崩溃的,文件结构大概是这样子&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AAAClass.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;AAAClass.m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BBBClass.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;BBBClass.m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CCCClass.h
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CCCClass.m
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;....
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;....
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;嗯,还没有文档&amp;hellip;..&lt;br&gt;
花了两天读了一下代码, 没有重构,没有继承,各种oop思想没有;&lt;/p&gt;
&lt;p&gt;生生把&lt;code&gt;Objective-C&lt;/code&gt;给写成了C语言;&lt;/p&gt;
&lt;p&gt;我想所有的程序员应该都知道, 代码是写给人看的, 不是写给机器和电脑看的..&lt;/p&gt;
&lt;p&gt;我觉得代码在设计和编写的时候更应该注重可读性,提高代码的可重用性,可维护性, 遵循这个原则,你的代码才不是写一次就丢掉的程序;&lt;/p&gt;
&lt;p&gt;当然,一个人做项目是挺爽,没有约束,天马行空,肆意汪洋,但是一周两周三周一个月两个月后呢,当你去维护项目的时候怎么办&amp;hellip;.&lt;/p&gt;
&lt;p&gt;对比Python和Perl这两种语言, 你可以用Python做到一切用Perl能到做到的事情, 但是做好之后, 你还可以阅读自己的程序代码;&lt;/p&gt;
&lt;p&gt;Python的美在于容易编写,容易阅读;更注重工程项目的可维护性;Perl就不一样,Perl很容易便携,但是程序员很难去阅读,你看代码很难猜到某一段代码的意图; 当然,这是因为两个语言的设计者背景不一样; 但是,这能体现人们选择使用Python的一些主要原因, 代码具有高度的统一性, 语法和工具集相当一致, 有一个很核心的概念, 简洁优美统一; Perl呢, 完成的方法不只有一种,所以,有了这种鼓励,每个人的代码风格都充满了独特性,充满技巧性;而这种独特的技巧常常是Perl使用者之间的骄傲来源;&lt;/p&gt;
&lt;p&gt;我想,任何做过实质性的代码维护工作的人,应该都可以正式, 自由的表达是一门很棒的艺术,但是对于一个工程来说就是很让人厌恶的一件事情了;&lt;/p&gt;
&lt;p&gt;在工程世界中,我们需要最小化功能集和可预测性;在工程世界中, 表达式自由度会造成维护的噩梦; 结果往往都是, 不行就推倒重来吧&amp;hellip;&lt;/p&gt;
&lt;p&gt;艺术和工程之间的关键差异在于个体的自由选择和一些独特的想法;但是一个优秀的程序员应该知道,代码应该是为下一个阅读它而进行维护或者重用的人写的.&lt;/p&gt;
&lt;p&gt;如果下一个人无法理解代码,那在实际开发场景中就毫无用处了; 所以呀,好好写代码; 做好文档建设工作,认真写注释;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CentOS 下安装 Redis</title>
        <link>http://47.99.84.217/post/centos-xia-an-zhuang-redis/</link>
        <pubDate>Sat, 15 Sep 2018 14:51:47 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/centos-xia-an-zhuang-redis/</guid>
        <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;安装Redis需要知道自己需要哪个版本，有针对性的安装，比如如果需要redis GEO这个地理集合的特性，那么redis版本就不能低于3.2版本，由于这个特性是3.2版本才有的。另外需要注意的是，Redis约定次版本号（即第一个小数点后的数字）为偶数的版本是稳定版（如2.8版、3.0版），奇数版本是非稳定版（如2.7版、2.9版），生产环境下一般需要使用稳定版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;下载安装包&#34;&gt;下载安装包&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget http://download.redis.io/releases/redis-4.0.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;解压并安装&#34;&gt;解压并安装&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tar xzf redis-4.0.2.tar.gz
cd redis-4.0.2
make
make install
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Redis没有其他外部依赖，安装过程很简单。编译后在Redis源代码目录的src文件夹中可以找到若干个可执行程序，安装完后，在/usr/local/bin目录中可以找到刚刚安装的redis可执行文件。 如下:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img.52smile.vip/2018-09-15-134934.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;redis 安装目录&#34;
	
	
&gt; 那你也可以通过命令 &lt;code&gt;redis -server&lt;/code&gt; 命令来执行启动 redis; 启动后界面如下: &lt;img src=&#34;https://img.52smile.vip/2018-09-15-135404.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;redis 启动界面&#34;
	
	
&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置初始化脚本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先将初始化脚本复制到/etc/init.d 目录中，文件名为 redis_端口号，其中端口号表示要让Redis监听的端口号，客户端通过该端口连接Redis。然后修改脚本第6行的REDISPORT变量的值为同样的端口号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立需要使用的文件夹&lt;/p&gt;
&lt;p&gt;目录名&lt;/p&gt;
&lt;p&gt;配置项&lt;/p&gt;
&lt;p&gt;/etc/redis&lt;/p&gt;
&lt;p&gt;存放redis 的配置文件&lt;/p&gt;
&lt;p&gt;/etc/redis/端口号&lt;/p&gt;
&lt;p&gt;存放 redis持久化文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;tip: vim 模式下使用 &lt;code&gt;?&lt;/code&gt; 命令进行搜索, &lt;code&gt;n&lt;/code&gt;跳转到下一个搜索结果;&lt;code&gt;N&lt;/code&gt;跳转上一个搜索结果 3.修改配置文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先将配置文件模板（redis-4.0.2/redis.conf）复制到/etc/redis 目录中，以端口号命名（eg: “6379.conf”），然后按照下表对其中的部分参数进行编辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;params&lt;/p&gt;
&lt;p&gt;value&lt;/p&gt;
&lt;p&gt;tip&lt;/p&gt;
&lt;p&gt;daemonize&lt;/p&gt;
&lt;p&gt;yes&lt;/p&gt;
&lt;p&gt;redis 以守护进程模式运行&lt;/p&gt;
&lt;p&gt;pidfile&lt;/p&gt;
&lt;p&gt;/var/run/redis_端口号.pid&lt;/p&gt;
&lt;p&gt;设置Redis的PID文件位置&lt;/p&gt;
&lt;p&gt;port&lt;/p&gt;
&lt;p&gt;端口号&lt;/p&gt;
&lt;p&gt;被监听的端口号 dir /var/redis/端口号 redis持久化文件&lt;/p&gt;
&lt;p&gt;配置完成以后你可以通过命令行启动 redis&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/etc/init.d/redis_6379 start
/etc/init.d/redis_6379 stop
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;别忘记配置自动启动~ 修改配置文件: &lt;code&gt;etc/init.d/redis_6379.conf;&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim etc/init.d/redis_6379.conf
在头部的第五行添加
# chkconfig: 2345 90 10
# description: Redis is a persistent key-value database
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;正确的停止-redis&#34;&gt;正确的停止 redis&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;考虑到 Redis 有可能正在将内存中的数据同步到硬盘中，强行终止 Redis 进程可能会导致数据丢失。正确停止Redis的方式应该是向Redis发送SHUTDOWN命令，方法为：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;redis-cli SHUTDOWN&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当Redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。Redis可以妥善处理 SIGTERM信号，所以使用 kill Redis 进程的 PID也可以正常结束Redis，效果与发送SHUTDOWN命令一样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ioser.net/archives/27&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考基友Martin的文章&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>js数组去重</title>
        <link>http://47.99.84.217/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
        <pubDate>Wed, 12 Sep 2018 15:25:33 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
        <description>&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近参与公司 ERP 项目, 负责了一下前端页面开发; 之前接触 js 比较浅, 在做项目中遇到了一些问题, 比如数组去重, 对象数组去重等问题;&lt;/p&gt;
&lt;h3 id=&#34;使用-arrayform-set集合&#34;&gt;使用 Array.form() set集合&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let arr = [1,1,2,3,4];
let result= Array.from(new Set(arr));
console.log(result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;遍历利用-indexof-判断&#34;&gt;遍历,利用 indexOf 判断&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let arr = [1,1,2,3,4];
var temp= [];
for (i in  arr){
    if(temp..indexOf(arr[i]) == -1){
        temp.push(arr[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;遍历-利用对象的-key-判断数据值&#34;&gt;遍历 利用对象的 key, 判断数据值&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var arr = [
    {id: &amp;#39;121&amp;#39;, count: 20},
    {id: &amp;#39;122&amp;#39;, count: 20},
    {id: &amp;#39;123&amp;#39;, count: 20},
    {id: &amp;#39;121&amp;#39;, count: 10},
    {id: &amp;#39;122&amp;#39;, count: 11}
];
let tempDict = {};
let newArr = [];
   for(let i=0;i&amp;lt;arr.length;i++) {
     if(!tempDict[arr[i].id]) {
       tempDict[arr[i].id] = true;
       newArr.push(arr[i]);
     }
   }
console.log(newArr);
Array(3)
{id: &amp;#34;121&amp;#34;, count: 20}
{id: &amp;#34;122&amp;#34;, count: 20}
{id: &amp;#34;123&amp;#34;, count: 20}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;foreach&#34;&gt;forEach&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;let arr1 = [{skuid:1111,count:222},{skuid:2222,count:3},{skuid:1111,count:222},{skuid:2222,count:3}];
let temp= [];
arr1.forEach(item =&amp;gt; {
                    item = Object.assign(item);
                    let sku = this.alertInfoArr.find(sku=&amp;gt;sku.skuId===item.skuId);
                    if(!sku){
                        temp.push(item);
                    }
                });
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>使用Hexo&#43;Coding搭建个人博客</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8hexocoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Tue, 17 Apr 2018 15:10:01 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8hexocoding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;p&gt;前言 之前博客挂在 github pages 上,回到新疆之后发现访问不了了.一琢磨就买个个主机使用 wordpress搭建了个个人博客,当使用 wordpress 实在是不能提起我的写作欲望,又麻溜的切换到了 hexo.在网上看到了coding 也提供了类似 github pages 的服务 coding-pages,瞬间觉得太好了.于是我又开始了 hexo 之旅;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;正文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境：　mac　os ＋　hexo3.0　＋ iTerm　＋ Mou　＋ next + homebrew １．　安装非常简单，只需要几分钟即可搞定；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;２．　查看你的电脑中有没有安装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js&lt;/li&gt;
&lt;li&gt;Git.&lt;/li&gt;
&lt;li&gt;如果您的电脑没有安装上诉的程序,可以点击访问安装;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了,如果这些步骤都完成,您就可以安装 hexo 了;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm install -g hexo-cli&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;建站 执行下面的命令,Hexo 会在文件夹中新建需要的文件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hexo init folder hexo init&lt;/code&gt;
~Document/Hexo e.g. cd folder npm install&lt;/p&gt;
&lt;p&gt;完成这一步之后,您就可以在您的 hexo 文件夹下执行 &lt;code&gt;hexo g hexo s&lt;/code&gt; 在浏览器中访问 &lt;code&gt;http://localhost:4000&lt;/code&gt;,这是您就能看到 Hexo 的页面了,是不是很帅!&lt;/p&gt;
&lt;p&gt;轻轻松松就看到了效果,有没有觉得很有成就感;&lt;/p&gt;
&lt;p&gt;当然这个博客是存在于您的本地;&lt;/p&gt;
&lt;p&gt;先别着急,咱们看一下本地怎么配置,怎么配置主题;&lt;/p&gt;
&lt;p&gt;在 Hexo 文件夹下有一个&lt;code&gt;config.yml&lt;/code&gt;,就叫他 站点配置文件吧;&lt;/p&gt;
&lt;p&gt;文件不大,加上注释空行也就八十多行;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site 
 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思 title: 两好三坏 #博客名 subtitle: 爱情,两好三坏 #副标题 description: 长恨人心不如水,等闲平地起波澜 #用于搜索，没有直观表现 author: 两好三坏 #作者 language: zh-CN #语言 timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值 # URL 暂不配置，使用默认值 ## If your site is put in a subdirectory, set url as &amp;#39;http://yoursite.com/child&amp;#39; and root as &amp;#39;/child/&amp;#39; url: http://opiece.me #域名 root: / permalink: :year/:month/:day/:title/ permalink\_defaults: # Directory 暂不配置，使用默认值 source\_dir: source public\_dir: public tag\_dir: tags archive\_dir: archives category\_dir: categories code\_dir: downloads/code i18n\_dir: :lang skip\_render: # Writing 文章布局等，使用默认值 new\_post\_name: :title.md # File name of new posts default\_layout: post titlecase: false # Transform title into titlecase external\_link: true # Open external links in new tab filename\_case: 0 render\_drafts: false post\_asset\_folder: false relative\_link: false future: true highlight: enable: true line\_number: true tab\_replace: # Category Tag 暂不配置，使用默认值 default\_category: uncategorized category\_map: tag\_map: # Date / Time format 时间格式，使用默认值 ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date\_format: YYYY-MM-DD time\_format: HH:mm:ss # Pagination ## Set per\_page to 0 to disable pagination per\_page: 10 #每页显示的文章数，0表示不分页 pagination\_dir: page # Extensions 插件配置，暂时不配置 ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: hexo-theme-next #使用的主题，即：themes文件夹下的主题文件夹名 feed: #之后配置rss会用，使用如下配置即可 type: path: limit: # Deployment 用于部署到github，之前已经配置过 ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repo: https://git.coding.net/usename/usename.git #coding仓库地址 branch: coding-pages 再次运行 hexo,看看 hexo 比第一次打开之后顺眼多了,至少变成汉字了吧~哈哈哈哈哈哈 切换主题,主题配置文件 在iTerm进入到 Hexo 目录下,然后执行 git 下载 next 主题 git clone https://github.com/iissnan/hexo-theme-next.git 下载完成后会在 hexo 下的 theme 文件下,文件名夹名为 hexo-theme-next,在站点配置文件中将主题设置为 hexo-theme-next;再次运行 hexo s 查看效果,是不是跟开心啦~~~ 在hexo-theme-next中有\_config.yml,这是是主题的配置文件 你可以在Next 帮助文档查看如何个性化定制; 写作]

*   你可以使用下列命令创建一个新的文章:
*   hexo new \[layout\] &amp;lt;title&amp;gt; ,layout 是布局,title 是文章标题; 写作是使用 markdown语法,你可以在MarkDown 语法入门查看; 如果你需要标签功能和分类功能,在终端进入到您的hexo文件夹下 执行:
*   hexo new page &amp;#34;tags&amp;#34; 创建标签页面,在hexo 文件夹下的 \\source\\tags\\index.md 中添加一个 type: “tags”
* [[  hexo new page categories 创建分类页面,在hexo 文件夹下的 \\source\\categories\\index.md 中添加一个 type: “categories” 然后你也可以在hexo 文件夹下的 \\scaffolds\\post.md 中添加一个上 tags: categories: ,这个 post 是你每次书写的时候的一个模板;添加后每次创建行的文章就不用去在添加 tags 和 categories 了;]]

部署 写作完成之后可以使用命令 hexo g生成静态页面.在后运行 hexo s查看效果; hexo d是部署到 coding 或者 github 上面,在站点配置文件中 deploy: type: git repo: https://git.coding.net/usename/usename.git #coding仓库地址 branch: coding-pages

*   你可以先到 coding 上面去申请一个帐号,然后行创建一个与你 coding 用户名相同的项目;
*   打开你刚才创建的项目,有一栏叫做 Page 服务,打开,然后选择部署;
*   hexo d是提交到你这个 repo的仓库,如果你没有配置 ssh,那么可能就提示您输入您的从coding 上的用户名和密码来验证;
*   如果宁蒗的输入,可以配置 ssh 公钥来进行配置点击查看配置 ssh 当您完成写作之后执行 hexo g &amp;amp; hexo s,过上一会就可以访问您的文章了;

绑定域名 如果您有自己的域名,你可以在在 dns 解析添加解析到 pages.coding.me;这样别人就可以通过域名访问您的博客了;
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>css盒子模型 - - 前端开发</title>
        <link>http://47.99.84.217/post/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</link>
        <pubDate>Tue, 17 Apr 2018 15:02:57 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/css%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</guid>
        <description>&lt;p&gt;css 框模型(BoxModel) 定义了元素框处理元素内容, 内/外边距,边框, 外边框的方式; CSS 框模型概述: 元素框的最内部分是实际的内容, 直接包围内容的是内边距(*padding); 内边距呈现的是元素的背景, 内边距的边缘是边框(border, 可设置bordercolor borderwidth); 边框以为是外边框 , 外边框的默认背景色是透明的, 因此不会遮挡其后的任何元素;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;内边距, 边框,外边距都是可选的, 默认值是0. 但是,许多元素将由用户代理样式表设置外边距和内边距. 可以通过将元素的margin 和padding 设置为0 来覆盖这些浏览器样式. 这样可以分别进行, 也可以使用通用选择器对所有元素进行设置:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; * {
    margin : 0;
    padding: 0;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 css 中, width 和height指的是内容区域的宽度和高度;增减内外边距和边框并不会影响内容区域的尺寸,但是影响元素框的总尺寸 假设框的每一个边上都有10 个像素的外边距和5个像素的内边距. 如果希望这个元素框达到100个像素, 那就需要将内容的宽度设置为 70 像素,:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#box {
width: 70px;
margin: 10px;
padding: 5px;
}
/*
tip:
 内外边距,边框都可以应用于一个元素的所有便, 也可以用于单独的边
 eg : border-left-width: 10px ;  ---&amp;gt; 单独给左侧边框线设置线宽为10px
 外边距可以使负值, 而且在很多情况下都要使用复制的外边距;
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CSS内边距: 元素的内边距在的边框和内容之间, 控制该区域最简单的属性是padding属性, css 的padding属性定义元素边框与元素内容之间的空白区域; css padding 属性 CSS padding 属性定义元素的内边距。padding 属性接受长度值或百分比值，但不允许使用负值。 例如，如果您希望所有 h1 元素的各边都有 10 像素的内边距，只需要这样： l&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;h1 {padding: 10px;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;您还可以按照上、右、下、左的顺序分别设置各边的内边距，各边均可以使用不同的单位或百分比值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;h1 {padding: 10px 0.25em 2ex 20%;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;单边内边距的属性值:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;padding-top 上内边距&lt;/li&gt;
&lt;li&gt;padding-bottom 下内边距&lt;/li&gt;
&lt;li&gt;padding-left 左内边距&lt;/li&gt;
&lt;li&gt;padding-right 右内边距 h1 { padding-top: 10px; padding-right: 0.25em; padding-bottom: 2ex; padding-left: 20%; }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS 边框 在 HTML 中，我们使用表格来创建文本周围的边框，但是通过使用 CSS 边框属性，我们可以创建出效果出色的边框，并且可以应用于任何元素。 元素外边距内就是元素的的边框 (border)。元素的边框就是围绕元素内容和内边据的一条或多条线。 每个边框有 3 个方面：宽度、样式，以及颜色。 边框与背景 CSS 规范指出，边框绘制在“元素的背景之上”。这很重要，因为有些边框是“间断的”（例如，点线边框或虚线框），元素的背景应当出现在边框的可见部分之间。 CSS2 指出背景只延伸到内边距，而不是边框。后来 CSS2.1 进行了更正：元素的背景是内容、内边距和边框区的背景。大多数浏览器都遵循 CSS2.1 定义，不过一些较老的浏览器可能会有不同的表现。 边框的样式 样式是边框最重要的一个方面，这不是因为样式控制着边框的显示（当然，样式确实控制着边框的显示），而是因为如果没有样式，将根本没有边框。 CSS 的 border-style 属性定义了 10 个不同的非 inherit 样式，包括 none。 例如，您可以为把一幅图片的边框定义为 outset，使之看上去像是“凸起按钮”：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a:link img {border-style: outset;}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义多种样式: p.aside {border-style: solid dotted dashed double;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义单边样式: border-top-style border-right-style border-bottom-style border-left-style&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边框的宽度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过border-width 置顶边框宽度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em；或者使用 3 个关键字之一，它们分别是 thin 、medium（默认值） 和 thick。 注释：CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px，而另一个用户代理则分别设置为 3px、2px 和 1px。 所以，我们可以这样设置边框的宽度：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {border-style: solid; border-width: 5px;}
or
p {border-style: solid; border-width: thick;}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义单边的线宽 p {border-style: solid; border-width: 15px 5px 15px 5px;} border-right-width border-bottom-width border-left-width border-top-width&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有边框&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果希望显示某种边框, 就需要设置边框样式 , 默认情况下 border-style 默认 是none ; 如果我们设置style 为none , 然后设置边框的宽度, 边框的样式是不存在的, 而且 边框的宽度自动设置成0 , 所以,我们需要设置边框的时候, 一定要使用 border-style 进行设置一下边框线的style; 边框的颜色 border-corlor 设置边框颜色非常简单。CSS 使用一个简单的 border-color 属性，它一次可以接受最多 4 个颜色值。 可以使用任何类型的颜色值，例如可以是命名颜色，也可以是十六进制和 RGB 值：\&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {
  border-style: solid;
  border-color: blue rgb(25%,35%,45%) #909090 red;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果颜色值小于 4 个，值复制就会起作用。例如下面的规则声明了段落的上下边框是蓝色，左右边框是红色：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {
  border-style: solid;
  border-color: blue red;
  }
/*
注释：默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色
相同。另一方面，如果元素没有任何文本，假设它是一个表格，其中只包含图像，那么该表的边
框颜色就是其父元素的文本颜色（因为 color 可以继承）。这个父元素很可能是 body、div
或另一个 table。
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义单边颜色&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;border-top-color
border-right-color
border-bottom-color
border-left-color
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;css margin 属性 外边距 绕在元素边框的空白区域是外边距。设置外边距会在元素外创建额外的“空白”。 设置外边距的最简单的方法就是使用 margin 属性，这个属性接受任何长度单位、百分数值甚至负值。 设置外边距最简单的方法就是使用margin属性 , margin 接受任意长度的单位, 像素, 毫米, 英寸,em 也可以设置成auto, 值赋值 我们有时候会输入一些重复的数字,来设置margin 或者 border 或者padding eg :&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p {margin: 0.5em 1em 0.5em 1em };
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过值复制, 你可以不用重复输入数字&amp;quot;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p{margin: 0.5em 1em};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两个数值可以取代前面的四个数值, CSS定义了一些规则, 允许外部安居指定少于4个值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺少左外边距, 默认使用右外边距&lt;/li&gt;
&lt;li&gt;缺少下外边距,默认使用上外边距&lt;/li&gt;
&lt;li&gt;缺少右外边距,使用上外边距;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;h1 {margin: 0.25em 1em 0.5em;}  /* 等价于 0.25em 1em 0.5em 1em */
h2 {margin: 0.5em 1em;}     /* 等价于 0.5em 1em 0.5em 1em */
p {margin: 1px;}            /* 等价于 1px 1px 1px 1px */
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Ajax 初识</title>
        <link>http://47.99.84.217/post/ajax-%E5%88%9D%E8%AF%86/</link>
        <pubDate>Tue, 17 Apr 2018 15:01:46 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/ajax-%E5%88%9D%E8%AF%86/</guid>
        <description>&lt;p&gt;Ajax AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。并不是一种开发语言,是聪明的程序员对 javascript 的创造性用法; Ajax 提供与服务器异步通信的能力,最简单的应用就是无需刷新整个页面而更新网页某一个部分的数据,更快,更高,更强~~~ 使用这个技术还是很简单的.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;1.创建 XMLHttpRequest 对象&lt;/p&gt;
&lt;p&gt;//创建对象的语法:&lt;/p&gt;
&lt;p&gt;variable = new XMLHttpRequest()lt;br/gt;&lt;/p&gt;
&lt;p&gt;//如果需要向下兼容 ie5,5,我们需要 ActiveX 对象lt;br/gt;&lt;/p&gt;
&lt;p&gt;variable = new ActiveXobject(quot;Microsoft.XMLHTTPquot;)lt;br/gt;&lt;/p&gt;
&lt;p&gt;var xmlhttp;&lt;/p&gt;
&lt;p&gt;if (window.XMLHttpRequest){&lt;/p&gt;
&lt;p&gt;xmlhttp=new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;}else{&lt;/p&gt;
&lt;p&gt;xmlhttp=new ActiveXObject(quot;Microsoft.XMLHTTPquot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这样我们就创建一个 XMLHttpRequest 的对象,我们就可以使用这个对象进行请求数据; ２.向服务器发送请求 如果我们向服务器发送请求，就需要用到xmlhttp 的 open()和send() 方法&lt;/p&gt;
&lt;p&gt;open()有三个参数,第一个参数是请求类型 put,get,post;&lt;/p&gt;
&lt;p&gt;第二个参数是 url,即文件在服务器上的地址&lt;/p&gt;
&lt;p&gt;第三个参数是同步 or 异步&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;open(method,url,asyns)&lt;/p&gt;
&lt;p&gt;!&amp;ndash;&lt;/p&gt;
&lt;p&gt;发送请求,string 用于 post 请求&lt;/p&gt;
&lt;p&gt;但我们需要提交一些表单之类的数据的时候,需要用到 post 提交&lt;/p&gt;
&lt;p&gt;需要在 setRequestHeader()中添加请求有信息,在后再 send()中添加数据&lt;/p&gt;
&lt;p&gt;--&lt;/p&gt;
&lt;p&gt;send(string)&lt;/p&gt;
&lt;p&gt;xmlhttp.onreadystatechange=function()&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;if (xmlhttp.readyStatelt;markgt;4 amp;amp; xmlhttp.statuslt;/markgt;200)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;// responseText amp; responseXML;一个是字符串形式的响应数据,一个是 xml 形式的响应数据XML 可以使用 name.getElementsByName(quot;节点名称quot;)进行读取&lt;/p&gt;
&lt;p&gt;document.getElementById(quot;myDivquot;).innerHTML=xmlhttp.responseText;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;xmlhttp.open(quot;GETquot;,url,true);&lt;/p&gt;
&lt;p&gt;xmlhttp.send();&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;上面的 readyState表示存有 XMLHttpRequest 的状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0:请求未初始化&lt;/li&gt;
&lt;li&gt;1:服务器连接已建立&lt;/li&gt;
&lt;li&gt;2:请求已经接受&lt;/li&gt;
&lt;li&gt;3:请求处理中&lt;/li&gt;
&lt;li&gt;4:请求已完成,响应就绪; 上面的 status&lt;/li&gt;
&lt;li&gt;200:”OK&lt;/li&gt;
&lt;li&gt;404:未找到页面&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>使用thinkphp分页&amp;上传图片</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8thinkphp%E5%88%86%E9%A1%B5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</link>
        <pubDate>Tue, 17 Apr 2018 14:49:42 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8thinkphp%E5%88%86%E9%A1%B5%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</guid>
        <description>&lt;p&gt;使用 thinkPHP 实现分页: 新建控制器LoginController.class.php 在 LoginController 中创建 index 方法:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Page 类 和 limit方法实现&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$data  = M(&amp;#39;userinfo&amp;#39;);
$map[&amp;#39;user_id&amp;#39;] = array(&amp;#39;gt&amp;#39;,0);
$count = $data-&amp;gt;where()-&amp;gt;count(); // 满足条件的记录数
//Page 的构造方法,第一个参数为总记录数,第二个是每页显示的数量
$page = new Page($count,5);
$show = $page-&amp;gt;show();
$list = $User-&amp;gt;where($map)-&amp;gt;order(&amp;#39;create_time&amp;#39;)-&amp;gt;limit($Page-&amp;gt;firstRow.&amp;#39;,&amp;#39;.$Page-&amp;gt;listRows)-&amp;gt;select();
$this-&amp;gt;assign(&amp;#39;list&amp;#39;,$list);// 赋值数据集
$this-&amp;gt;assign(&amp;#39;page&amp;#39;,$show);// 赋值分页输出
$this-&amp;gt;display();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在对应的试图模板中编写如下代码:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;table cellpadding=3 cellspacing=5&amp;gt;
    &amp;lt;volist name=&amp;#34;list&amp;#34; id=&amp;#34;vo&amp;#34;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td &amp;gt;[ {$vo.user_id} ] {$vo.user_id} &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/volist&amp;gt;
    &amp;lt;tr&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;div class=&amp;#34;resultpage&amp;#34; style=&amp;#34;width: 500px&amp;#34;&amp;gt;{$page}&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样在对应的视图就会显示相应的页码和数据信息;不过有点难看,不过别担心,稍后咱们在重新设置; 接下来咱们看第二种实现方式: 分页类和 page 方法的实现 将 index 方法中的代码替换成如下:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$data  = M(&amp;#39;userinfo&amp;#39;);
$map[&amp;#39;user_id&amp;#39;] = array(&amp;#39;gt&amp;#39;,0);
$list = $data-&amp;gt;where($map)-&amp;gt;order(&amp;#39;user_id)-&amp;gt;page($_GET[&amp;#39;p&amp;#39;].&amp;#39;,5&amp;#39;)-&amp;gt;select();
$this-&amp;gt;assgin(&amp;#39;list&amp;#39;,$list);
//引入分页模块
$count = $data-&amp;gt;where($map)-&amp;gt;count();
$page = new Page($count, &amp;#39;5&amp;#39;);
$show = $page-&amp;gt;show();
$this -&amp;gt; assgin(&amp;#39;page&amp;#39;,$show);
$this-&amp;gt;display();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改分页显示效果 thinkphp 中的分页类 Page 提供了一个方法 setConfig 来修改分页栏的显示效果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;header：头部描述信息，默认值 “条记录”&lt;/li&gt;
&lt;li&gt;prev：上一页描述信息，默认值是“上一页”&lt;/li&gt;
&lt;li&gt;next：下一页描述信息，默认值是“下一页”&lt;/li&gt;
&lt;li&gt;first：第一页描述信息，默认值是“第一页”&lt;/li&gt;
&lt;li&gt;last：最后一页描述信息，默认值是“最后一页”&lt;/li&gt;
&lt;li&gt;theme ：分页主题描述信息， `` $page-&amp;gt;lastSuffix = false; $page-&amp;gt;setConfig(&amp;lsquo;header&amp;rsquo;,&amp;lsquo;共**%TOTAL_ROW%**条记录&amp;rsquo;); $page-&amp;gt;setConfig(&amp;lsquo;prev&amp;rsquo;,&amp;rsquo;&amp;lt;&amp;rsquo;); $page-&amp;gt;setConfig(&amp;rsquo;next&amp;rsquo;,&amp;rsquo;&amp;gt;&amp;rsquo;); $page-&amp;gt;setConfig(&amp;lsquo;first&amp;rsquo;,&amp;lsquo;首页&amp;rsquo;); $page-&amp;gt;setConfig(&amp;rsquo;last&amp;rsquo;,&amp;lsquo;尾页&amp;rsquo;); $page-&amp;gt;setConfig(&amp;rsquo;theme&amp;rsquo;, &amp;lsquo;%FIRST%%UP_PAGE%%LINK_PAGE%%DOWN_PAGE%%END%%HEADER%&amp;rsquo;); 我们还可以使用 &lt;code&gt;css&lt;/code&gt; 属性对分页栏的显示效果进行修改: 上面列表中的 &lt;code&gt;header&lt;/code&gt; &lt;code&gt;prev&lt;/code&gt; &lt;code&gt;next&lt;/code&gt; 等等再视图模板中都是以元素的 &lt;code&gt;class&lt;/code&gt; 值体现的,所以我们可以通过修改 class 的样式表定制显示效果,达到我们想要的效果:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.resultpage{&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;background: black;
color: honeydew;
margin-right: 5px;
margin-left: 5px;
padding-left: 5px;
padding-right: 5px;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;.num {&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;color: honeydew;
padding-left: 5px;
padding-right: 5px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;} .current{color: red;} .prev{color: honeydew;} .next{color: honeydew;} .last{color: honeydew;} .first{color: honeydew;} a{text-decoration: none}&lt;/p&gt;
</description>
        </item>
        <item>
        <title>使用cookie实现自动登录</title>
        <link>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</link>
        <pubDate>Tue, 17 Apr 2018 14:48:57 +0800</pubDate>
        
        <guid>http://47.99.84.217/post/%E4%BD%BF%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</guid>
        <description>&lt;p&gt;关于 cookie 在日常开发中我们会遇到这样的需求场景: 用户在首次登录使用后,离开了这个网站(没有点击注销登录), 再次回到这个站点的时候,不需要重新登录,仍是自己上次登陆的账号信息; 我们可以使用 cookie 中存储用户的信息,并且判断是否需要加载用户信息并重新登录; php 使用 setCookie 函数来设置 Cookie 信息,但是有一点值得注意,Cookie是HTTP协议头的一部分，用于浏览器和服务器之间传递信息，&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;所以必须在任何属于HTML文件本身的内容输出之前调用Cookie函数。 也就是说,在 setcookie 之前不能进行输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo &amp;#39;我要设置 cookie了&amp;#39;;
setCookie(&amp;#39;value&amp;#39;,&amp;#39;key&amp;#39;,time());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种会造成设置 cookie 无效; 使用 cookie 实现自动登录 登陆成功后存储用户的信息: 在登录成功后通过 setCookie 设置用户信息,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; public function login()
 {
    if (!empty($_POST)){
        $userpsw = array(
            &amp;#39;username&amp;#39;=&amp;gt;$_POST[&amp;#39;username&amp;#39;],
            &amp;#39;password&amp;#39;=&amp;gt;$_POST[&amp;#39;password&amp;#39;],
         );
        $info = D(&amp;#39;userinfo&amp;#39;)-&amp;gt;where($userpsw)-&amp;gt;find();
        if ($info){
            $re = setcookie(&amp;#39;userinfo&amp;#39;,md5($_POST[&amp;#39;username&amp;#39;]),time()+3600,&amp;#39;/&amp;#39;);
            $re = setcookie(&amp;#39;password&amp;#39;,MD5($_POST[&amp;#39;password&amp;#39;]),time()+3600,&amp;#39;/&amp;#39;);
            dump($re);
            echo &amp;#39;登陆成功&amp;#39;;
            $this-&amp;gt;display();
            }else{
                echo &amp;#39;登录失败&amp;#39;;
            }
        }
    }else{
        $this-&amp;gt;display();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 cookie 我们还可以保存用户的偏好设置信息,在用户下次访问的时候推送用户可能会感兴趣的信息; 判断是否需要自动登录 可以再模板文件中通过 js 获取 cookie 进行判断是否需要自动加载用户信息,也可以在 php 的控制其中进行判断,&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt;
$(document).ready(function () {
var name = getCookie(&amp;#39;nickname&amp;#39;);
var password = getCookie(&amp;#39;psw&amp;#39;);
if(name &amp;amp;&amp;amp; password){
    //自动登录
}else{
    //手动登录
}
   console.log(getCookie(&amp;#39;nickname&amp;#39;));
});
function getCookie(c_name)
{
    if (document.cookie.length&amp;gt;0)
    {
        c_start=document.cookie.indexOf(c_name + &amp;#34;=&amp;#34;)
        if (c_start!=-1)
        {
            c_start=c_start + c_name.length+1
            c_end=document.cookie.indexOf(&amp;#34;;&amp;#34;,c_start)
            if (c_end==-1) c_end=document.cookie.length
            return unescape(document.cookie.substring(c_start,c_end))
        }
    }
    return &amp;#34;&amp;#34;
}
&amp;lt;/script&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        
    </channel>
</rss>
